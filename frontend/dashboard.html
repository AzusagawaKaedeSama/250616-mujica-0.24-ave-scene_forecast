<!DOCTYPE html>
<html lang="zh-CN" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>电力负荷预测系统 - 智能预测平台</title>
    
    <!-- 首先加载所有第三方库 -->
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    
    <!-- ECharts 引入 -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    
    <!-- React -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- React Chart.js -->
    <script src="https://unpkg.com/react-chartjs-2@5.2.0/dist/index.umd.js"></script>
    
    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <!-- Custom Styles -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        :root {
            --primary-light: #2563eb;
            --primary-dark: #3b82f6;
            --bg-light: #ffffff;
            --bg-dark: #111827;
            --text-light: #1f2937;
            --text-dark: #f9fafb;
        }

        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s, color 0.3s;
        }

        .dark {
            color-scheme: dark;
        }

        /* 平滑滚动 */
        html {
            scroll-behavior: smooth;
        }

        /* 渐入动画 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }

        /* 自定义滚动条 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        .dark ::-webkit-scrollbar-thumb {
            background: #475569;
        }

        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
        }

        .btn-hover {
            transition: all 0.2s;
        }
        
        .btn-hover:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        .card-hover {
            transition: all 0.3s;
        }
        
        .card-hover:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
    </style>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#eff6ff',
                            100: '#dbeafe',
                            200: '#bfdbfe',
                            300: '#93c5fd',
                            400: '#60a5fa',
                            500: '#3b82f6',
                            600: '#2563eb',
                            700: '#1d4ed8',
                            800: '#1e40af',
                            900: '#1e3a8a',
                        }
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.5s ease-out forwards',
                    },
                }
            }
        }
    </script>
    <!-- 在head底部, </head>标签前添加 -->
    <script>
        // ECharts加载检查
        window.addEventListener('load', function() {
            // 检查ECharts是否已加载
            if (typeof echarts === 'undefined') {
                console.warn('ECharts未通过CDN加载，尝试备用加载...');
                
                // 创建备用加载
                var scriptElement = document.createElement('script');
                scriptElement.src = 'https://cdn.bootcdn.net/ajax/libs/echarts/5.4.3/echarts.min.js';
                scriptElement.onload = function() {
                    console.log('ECharts通过备用CDN成功加载');
                };
                scriptElement.onerror = function() {
                    console.error('ECharts备用CDN加载失败。使用本地fallback...');
                    // 最后尝试，用本地备份
                    var lastScript = document.createElement('script');
                    lastScript.src = '/static/js/echarts.min.js';
                    document.head.appendChild(lastScript);
                };
                document.head.appendChild(scriptElement);
            } else {
                console.log('ECharts已成功加载，版本:', echarts.version);
            }
        });
    </script>
</head>
<body class="bg-gray-50 text-gray-900 dark:bg-gray-900 dark:text-gray-100 min-h-screen flex flex-col">
    <div id="app" class="flex-grow"></div>

    <script type="text/babel">
        // 确认echarts是否正确加载
        console.log("Available libraries check:", {
            Chart: typeof window.Chart !== 'undefined',
            ECharts: typeof window.echarts !== 'undefined',
            React: typeof window.React !== 'undefined',
            ReactDOM: typeof window.ReactDOM !== 'undefined'
        });
        
        // 如果ECharts未加载，尝试再次加载
        if (typeof window.echarts === 'undefined') {
            console.warn("ECharts未加载，尝试再次加载...");
            const echartsScript = document.createElement('script');
            echartsScript.src = "https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js";
            document.head.appendChild(echartsScript);
        }
        
        // React组件
        const { useState, useEffect, useRef, useCallback, useMemo } = React;
        
        // 确认react-chartjs-2是否正确加载
        console.log("Available chart libraries:", {
            Chart: window.Chart,
            reactChartJs2: window.reactChartJs2
        });
        
        // 修正Chart组件引用
        const Chart = window.Chart;
        const Line = window.reactChartJs2 ? window.reactChartJs2.Line : null;
        const Bar = window.reactChartJs2 ? window.reactChartJs2.Bar : null;
        
        // Register the annotation plugin globally
        if (window.Chart && window.ChartJSAnnotation) {
            Chart.register(window.ChartJSAnnotation);
            console.log("Chart.js Annotation plugin registered globally.");
        } else {
            console.warn("Chart.js or Annotation plugin not found for registration.");
        }
        
        // 如果React-ChartJS-2没有加载，则创建自定义图表组件
        const ChartComponent = ({ type, data, options, ...props }) => {
            const chartRef = useRef(null);
            const [chartInstance, setChartInstance] = useState(null);
            
            useEffect(() => {
                if (!chartRef.current) return;
                
                // 清理旧图表
                if (chartInstance) {
                    chartInstance.destroy();
                }
                
                // 创建新图表
                const ctx = chartRef.current.getContext('2d');
                const newChart = new Chart(ctx, {
                    type: type,
                    data: data,
                    options: options
                });
                
                setChartInstance(newChart);
                
                return () => {
                    if (newChart) {
                        newChart.destroy();
                    }
                };
            }, [data, options, type]);
            
            return <canvas ref={chartRef} {...props} />;
        };

        // 后端API URL
        const API_BASE_URL = 'http://localhost:5001/api';

        // 预测结果图表渲染函数 - 使用ECharts
        const renderPredictionChart = (data) => {
            try {
                // 首先记录详细的库加载状态
                console.log("渲染预测图表，库加载状态:", {
                    echarts: typeof echarts !== 'undefined',
                    window_echarts: typeof window.echarts !== 'undefined',
                    Chart: typeof Chart !== 'undefined',
                    Line: typeof Line !== 'undefined',
                    data_sample: data ? (data.predictions ? data.predictions.slice(0, 3) : "没有predictions") : "数据为null"
                });
                
                // 首先检查ECharts是否正确加载
                if (typeof echarts === 'undefined' && typeof window.echarts === 'undefined') {
                    console.error("ECharts库未加载！尝试使用Chart.js兜底...");
                    
                    // 如果ECharts不可用，使用Chart.js作为备选
                    if (typeof Chart !== 'undefined') {
                        return renderChartJsFallback(data);
                    }
                    
                    // 如果都不可用，显示错误信息
                    console.error("Chart.js也未加载，无法渲染图表");
                    const chartContainer = document.getElementById('prediction-chart');
                    if (chartContainer) {
                        chartContainer.innerHTML = `
                            <div class="flex flex-col items-center justify-center h-full p-4 text-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-red-500 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                                </svg>
                                <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-2">图表加载失败</h3>
                                <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">无法加载图表库。请刷新页面或检查网络连接。</p>
                                <button 
                                    class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                                    onClick="location.reload()"
                                >
                                    刷新页面
                                </button>
                            </div>
                        `;
                    }
                    
                    // 尝试动态加载ECharts以备下次使用
                    const script = document.createElement('script');
                    script.src = "https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js";
                    script.onload = function() {
                        console.log("ECharts库已动态加载，下次渲染将可用");
                        window.echartsLoaded = true;
                    };
                    document.head.appendChild(script);
                    return null;
                }
                
                // 使用可用的echarts变量
                const echartsLib = (typeof echarts !== 'undefined') ? echarts : window.echarts;

                if (!data || !data.predictions || data.predictions.length === 0) {
                    return null;
                }

                // 其余代码保持不变...
                // 配置图表容器高度
                const chartHeight = 600;
                
                // 准备数据
                const isNetLoadScenario = data.is_net_load === true;
                const predictions = data.predictions || [];

                const chartData = {
                    xAxis: predictions.map(p => p.datetime),
                    actual: predictions.map(p => p.actual), // This is Gross Load Actual
                    unit: data.forecast_type === 'load' ? '功率 (MW)' : 
                          data.forecast_type === 'pv' ? '光伏出力 (MW)' : 
                          data.forecast_type === 'wind' ? '风电出力 (MW)' : '功率 (MW)',
                    hasPeakInfo: predictions.some(p => 'is_peak' in p),
                    hasQuantiles: !isNetLoadScenario && (data.is_probabilistic || (data.quantiles && data.quantiles.length > 0))
                };

                // 其余数据准备逻辑保持不变...

                // 获取或创建图表容器
                const chartContainer = document.getElementById('prediction-chart');
                if (!chartContainer) return null;
                
                // 清除现有图表
                chartContainer.innerHTML = '';
                chartContainer.style.height = `${chartHeight}px`;
                
                // 尝试创建ECharts实例，使用try-catch捕获可能的错误
                let chart;
                try {
                    // 使用之前确定的echartsLib变量
                    chart = echartsLib.init(chartContainer);
                } catch (err) {
                    console.error("ECharts初始化失败:", err);
                    // 尝试使用Chart.js作为备选
                    return renderChartJsFallback(data);
                }
                
                // 开始图表渲染
                // 格式化日期时间
                const formatTime = (datetime) => {
                    const date = new Date(datetime);
                    return `${date.getMonth()+1}/${date.getDate()} ${date.getHours()}:${String(date.getMinutes()).padStart(2, '0')}`;
                };
                
                // 准备X轴数据
                const xAxisData = predictions.map(p => formatTime(p.datetime));
                
                // 准备系列数据
                const series = [];
                
                // 根据预测类型设置颜色
                const colors = {
                    predicted: '#5470c6',          // 蓝色
                    actual: '#ee6666',             // 红色
                    upper: '#91cc75',              // 绿色
                    lower: '#91cc75',              // 绿色
                    pv: '#fac858',                 // 黄色
                    wind: '#73c0de',               // 浅蓝色
                    net: '#fc8452',                // 橙色
                    upper_bound: '#91cc75',        // 绿色
                    lower_bound: '#91cc75',        // 绿色
                    confidence_area: 'rgba(145, 204, 117, 0.3)' // 浅绿色半透明
                };
                
                // 检查是否为区间预测
                const isIntervalForecast = data.predictionType === 'interval' || 
                                          (data.upper_bound && data.lower_bound) || 
                                          predictions.some(p => p.upper_bound !== undefined || p.lower_bound !== undefined);
                
                // 如果是净负荷预测场景
                if (isNetLoadScenario) {
                    // 净负荷预测特有的系列配置
                    series.push({
                        name: '总负荷预测',
                        type: 'line',
                        data: predictions.map(p => p.predicted),
                        lineStyle: { width: 2 },
                        itemStyle: { color: colors.predicted }
                    });
                    
                    series.push({
                        name: '净负荷预测',
                        type: 'line',
                        data: predictions.map(p => p.predicted_net),
                        lineStyle: { width: 2 },
                        itemStyle: { color: colors.net }
                    });
                    
                    series.push({
                        name: '光伏预测',
                        type: 'line',
                        data: predictions.map(p => p.pv_predicted),
                        lineStyle: { width: 2 },
                        itemStyle: { color: colors.pv }
                    });
                    
                    series.push({
                        name: '风电预测',
                        type: 'line',
                        data: predictions.map(p => p.wind_predicted),
                        lineStyle: { width: 2 },
                        itemStyle: { color: colors.wind }
                    });
                } 
                // 如果是区间预测
                else if (isIntervalForecast) {
                    // 准备数据
                    const upperBoundData = predictions.map(p => p.upper_bound !== undefined ? p.upper_bound : null);
                    const lowerBoundData = predictions.map(p => p.lower_bound !== undefined ? p.lower_bound : null);
                    const pointForecastData = predictions.map(p => p.predicted || p.point_forecast || null);
                    
                    // 检查是否有有效数据
                    const hasValidData = pointForecastData.some(v => v !== null) &&
                                      upperBoundData.some(v => v !== null) &&
                                      lowerBoundData.some(v => v !== null);
                    
                    if (hasValidData) {
                        // 添加区间填充 - 这种方式在ECharts中效果最好
                        series.push({
                            name: '置信区间',
                            type: 'line',
                            data: upperBoundData,
                            lineStyle: { width: 0 },
                            stack: 'confidence',
                            symbol: 'none'
                        });
                        
                        series.push({
                            name: '置信区间',
                            type: 'line',
                            data: lowerBoundData,
                            lineStyle: { width: 0 },
                            areaStyle: {
                                color: colors.confidence_area,
                                opacity: 0.3
                            },
                            stack: 'confidence',
                            symbol: 'none',
                            z: 1
                        });
                        
                        // 添加上下界线条
                        series.push({
                            name: '上界',
                            type: 'line',
                            data: upperBoundData,
                            lineStyle: { width: 1.5, type: 'dashed' },
                            itemStyle: { color: colors.upper_bound },
                            symbol: 'circle',
                            symbolSize: 3,
                            z: 3
                        });
                        
                        series.push({
                            name: '下界',
                            type: 'line',
                            data: lowerBoundData,
                            lineStyle: { width: 1.5, type: 'dashed' },
                            itemStyle: { color: colors.lower_bound },
                            symbol: 'circle',
                            symbolSize: 3,
                            z: 3
                        });
                        
                        // 添加预测值系列 - 始终放在最后，确保它在最上层
                        series.push({
                            name: '预测值',
                            type: 'line',
                            data: pointForecastData,
                            lineStyle: { width: 2.5 },
                            itemStyle: { color: colors.predicted },
                            symbol: 'circle',
                            symbolSize: 6,
                            z: 5  // 确保线在最上层
                        });
                    } else {
                        // 没有有效数据时，只显示预测线
                        series.push({
                            name: '预测值',
                            type: 'line',
                            data: pointForecastData,
                            lineStyle: { width: 2.5 },
                            itemStyle: { color: colors.predicted },
                            symbol: 'circle',
                            symbolSize: 6
                        });
                    }
                } 
                // 普通预测场景
                else {
                    series.push({
                        name: '预测值',
                        type: 'line',
                        data: predictions.map(p => p.predicted),
                        lineStyle: { width: 2 },
                        itemStyle: { color: colors.predicted }
                    });
                }
                
                // 添加实际值系列 (如果存在)
                const hasActualData = predictions.some(p => p.actual !== undefined && p.actual !== null);
                if (hasActualData) {
                    series.push({
                        name: '实际值',
                        type: 'line',
                        data: predictions.map(p => p.actual),
                        lineStyle: { width: 2 },
                        itemStyle: { color: colors.actual }
                    });
                }
                
                // 构建ECharts选项
                const option = {
                    title: {
                        text: `${data.forecast_type === 'load' ? '负荷' : data.forecast_type === 'pv' ? '光伏' : data.forecast_type === 'wind' ? '风电' : ''}预测结果`,
                        textStyle: {
                            color: document.documentElement.classList.contains('dark') ? '#ffffff' : '#333333'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            // 确保有数据
                            if (!params || params.length === 0) return '';
                            
                            let result = params[0].axisValue + '<br/>';
                            
                            // 首先添加正常系列
                            params.forEach(param => {
                                if (param && param.seriesName !== '置信区间') {
                                    // 确保值存在且不是null或undefined
                                    const value = param.value !== null && param.value !== undefined ? 
                                        param.value.toFixed(2) : 'N/A';
                                    result += `${param.marker} ${param.seriesName}: ${value} MW<br/>`;
                                }
                            });
                            
                            // 计算误差（如果有预测值和实际值）
                            const predictedItem = params.find(param => param && param.seriesName === '预测值');
                            const actualItem = params.find(param => param && param.seriesName === '实际值');
                            
                            if (predictedItem && actualItem && 
                                predictedItem.value !== null && predictedItem.value !== undefined && 
                                actualItem.value !== null && actualItem.value !== undefined) {
                                let error = 0;
                                let errorPct = 0;
                                
                                // 处理无限大误差问题（针对光伏）
                                if (actualItem.value === 0 || actualItem.value === null) {
                                    // 如果实际值为0，但预测值不为0，显示固定60%误差
                                    if (predictedItem.value > 0) {
                                        errorPct = 60;
                                        result += `<br/><span style="color: #ff9800;">误差: ${errorPct.toFixed(2)}% (实际值为0)</span>`;
                                    }
                                } else {
                                    error = Math.abs(predictedItem.value - actualItem.value);
                                    errorPct = (error / Math.abs(actualItem.value)) * 100;
                                    
                                    // 如果误差无限大或过大，限制为60%
                                    if (!isFinite(errorPct) || errorPct > 1000) {
                                        errorPct = 60;
                                        result += `<br/><span style="color: #ff9800;">误差: ${errorPct.toFixed(2)}% (限制值)</span>`;
                                    } else {
                                        result += `<br/><span style="color: #ff9800;">误差: ${errorPct.toFixed(2)}%</span>`;
                                    }
                                }
                            }
                            
                            return result;
                        }
                    },
                    legend: {
                        data: series.filter(s => s.name !== '置信区间').map(s => s.name),
                        textStyle: {
                            color: document.documentElement.classList.contains('dark') ? '#ffffff' : '#333333'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: xAxisData,
                        axisLabel: {
                            rotate: 45,
                            color: document.documentElement.classList.contains('dark') ? '#aaaaaa' : '#666666'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: chartData.unit,
                        nameTextStyle: {
                            color: document.documentElement.classList.contains('dark') ? '#aaaaaa' : '#666666'
                        },
                        axisLabel: {
                            formatter: '{value} MW',
                            color: document.documentElement.classList.contains('dark') ? '#aaaaaa' : '#666666'
                        }
                    },
                    series: series
                };
                
                // 设置选项并渲染图表
                chart.setOption(option);
                
                // 添加window resize事件监听
                window.addEventListener('resize', function() {
                    if (chart && typeof chart.resize === 'function') {
                        try {
                            chart.resize();
                        } catch (e) {
                            console.error("图表resize失败", e);
                        }
                    }
                });
                
                return chart;
            } catch (err) {
                console.error("预测图表渲染错误:", err);
                // 尝试备选渲染
                return renderChartJsFallback(data);
            }
        };

        // 添加一个使用Chart.js的备选渲染函数
        const renderChartJsFallback = (data) => {
            if (!data || !data.predictions || data.predictions.length === 0) {
                return null;
            }
            
            // 检查Chart.js是否可用
            if (typeof Chart === 'undefined') {
                console.error("Chart.js库也不可用，无法渲染图表");
                return null;
            }
            
            console.log("使用Chart.js作为备选渲染预测图表");
            
            // 获取图表容器
            const chartContainer = document.getElementById('prediction-chart');
            if (!chartContainer) return null;
            
            // 清空容器
            chartContainer.innerHTML = '<canvas id="prediction-chart-canvas"></canvas>';
            
            // 获取canvas上下文
            const ctx = document.getElementById('prediction-chart-canvas').getContext('2d');
            
            // 准备数据
            const isNetLoadScenario = data.is_net_load === true;
            const predictions = data.predictions || [];
            
            const labels = predictions.map(p => {
                const date = new Date(p.datetime);
                return `${date.getMonth()+1}/${date.getDate()} ${date.getHours()}:${date.getMinutes().toString().padStart(2, '0')}`;
            });
            
            const datasets = [];
            
            // 添加预测值
            if (isNetLoadScenario) {
                // 添加总负荷预测
                datasets.push({
                    label: '总负荷预测',
                    data: predictions.map(p => p.predicted),
                    borderColor: 'rgb(16, 185, 129)', // green
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    tension: 0.1
                });
                
                // 添加净负荷预测
                datasets.push({
                    label: '净负荷预测',
                    data: predictions.map(p => p.predicted_net),
                    borderColor: 'rgb(37, 99, 235)', // blue
                    backgroundColor: 'rgba(37, 99, 235, 0.1)',
                    borderWidth: 2,
                    tension: 0.1
                });
                
                // 添加光伏预测
                datasets.push({
                    label: '光伏预测',
                    data: predictions.map(p => p.pv_predicted),
                    borderColor: 'rgb(245, 158, 11)', // amber
                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                    borderWidth: 2,
                    tension: 0.1
                });
                
                // 添加风电预测
                datasets.push({
                    label: '风电预测',
                    data: predictions.map(p => p.wind_predicted),
                    borderColor: 'rgb(99, 102, 241)', // indigo
                    backgroundColor: 'rgba(99, 102, 241, 0.1)',
                    borderWidth: 2,
                    tension: 0.1
                });
            } else {
                // 普通预测
                datasets.push({
                    label: '预测值',
                    data: predictions.map(p => p.predicted),
                    borderColor: 'rgb(84, 112, 198)',
                    backgroundColor: 'rgba(84, 112, 198, 0.1)',
                    borderWidth: 2,
                    tension: 0.1
                });
            }
            
            // 添加实际值
            datasets.push({
                label: '实际值',
                data: predictions.map(p => p.actual),
                borderColor: 'rgb(238, 102, 102)', // red
                backgroundColor: 'rgba(238, 102, 102, 0.1)',
                borderWidth: 2,
                tension: 0.1
            });
            
            // 创建图表
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        x: {
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: data.forecast_type === 'load' ? '功率 (MW)' : 
                                      data.forecast_type === 'pv' ? '光伏出力 (MW)' : 
                                      data.forecast_type === 'wind' ? '风电出力 (MW)' : '功率 (MW)'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                afterLabel: function(context) {
                                    const datasetIndex = context.datasetIndex;
                                    const dataIndex = context.dataIndex;
                                    
                                    // 如果是预测值和实际值，计算误差
                                    if (datasetIndex === 0 && datasets.length > 1) {
                                        const predicted = datasets[0].data[dataIndex];
                                        const actual = datasets[datasets.length - 1].data[dataIndex];
                                        
                                        if (predicted !== null && actual !== null && actual !== 0) {
                                            const errorPct = Math.abs((predicted - actual) / actual * 100).toFixed(2);
                                            return `误差: ${errorPct}%`;
                                        }
                                    }
                                    return null;
                                }
                            }
                        }
                    }
                }
            });
            
            return chart;
        };

        // 主题切换
        function ThemeToggle() {
            const [isDark, setIsDark] = useState(document.documentElement.classList.contains('dark'));

            useEffect(() => {
                // 检查系统偏好
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                if (prefersDark && !isDark) {
                    setIsDark(true);
                }
            }, []);

            useEffect(() => {
                if (isDark) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            }, [isDark]);

            return (
                <button 
                    onClick={() => setIsDark(!isDark)}
                    className="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors btn-hover"
                    aria-label="切换主题"
                >
                    {isDark ? (
                        <span className="material-icons">light_mode</span>
                    ) : (
                        <span className="material-icons">dark_mode</span>
                    )}
                </button>
            );
        }

        // 日期选择器
        function DatePicker({ label, value, onChange, min, max }) {
            return (
                <div className="mb-4">
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                        {label}
                    </label>
                    <input 
                        type="date" 
                        value={value}
                        onChange={(e) => onChange(e.target.value)}
                        min={min}
                        max={max}
                        className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                    />
                </div>
            );
        }

        // 数字输入组件 (Helper)
        function NumberInput({ label, value, onChange, min, max, step = 1 }) {
            return (
                <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                        {label}
                    </label>
                    <input 
                        type="number" 
                        value={value}
                        onChange={(e) => onChange(parseFloat(e.target.value))}
                        min={min}
                        max={max}
                        step={step}
                        className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                    />
                </div>
            );
        }

        // 指标展示组件
        function MetricsDisplay({ metrics, type }) {
            if (!metrics || Object.keys(metrics).length === 0) {
                return <div className="text-sm text-gray-500 italic">无评估指标 (可能缺少实际值)</div>;
            }
            
            // Define which metrics to show based on type (PV/Wind might not have peak/valley)
            const metricKeysToShow = type === 'load' 
                ? ["mape", "peak_mape", "valley_mape", "max_error"]
                : ["mape", "max_error"]; // Default for PV/Wind

            const formatMetric = (key) => {
                switch(key) {
                    case 'mape': return '平均绝对百分比误差 (MAPE)';
                    case 'peak_mape': return '高峰MAPE';
                    case 'valley_mape': return '低谷MAPE';
                    case 'max_error': return '最大误差 (%)';
                    default: return key;
                }
            };

            // 如果metrics对象存在但不包含任何需要显示的指标
            const hasVisibleMetrics = metricKeysToShow.some(key => 
                metrics[key] !== undefined && metrics[key] !== null
            );
            
            if (!hasVisibleMetrics) {
                return <div className="text-sm text-gray-500 italic">无可用指标</div>;
            }

            return (
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-center fade-in">
                    {metricKeysToShow.map(key => (
                        metrics[key] !== undefined && metrics[key] !== null ? (
                            <div key={key} className="bg-gray-100 dark:bg-gray-800 p-3 rounded-lg card-hover">
                                <p className="text-sm text-gray-500 dark:text-gray-400">{formatMetric(key)}</p>
                                <p className="text-xl font-semibold text-primary-600 dark:text-primary-400">{metrics[key]}%</p>
                            </div>
                        ) : null
                    ))}
                </div>
            );
        }

        // 指标卡片组件 (This will be replaced by PredictionInsights)
        /*
        function MetricsCard({ metrics }) {
            // ... existing MetricsCard code ...
        }
        */

        // 参数设置组件
        function ParameterSettings({ 
            type, onSubmit, isLoading, availableProvinces, 
            selectedProvince, setSelectedProvince,
            forecastType, setForecastType, 
            // 添加从App传入的状态和设置函数
            historicalDays, setHistoricalDays,
            peakStart, setPeakStart,
            peakEnd, setPeakEnd,
            valleyStart, setValleyStart,
            valleyEnd, setValleyEnd,
            peakWeight, setPeakWeight,
            valleyWeight, setValleyWeight,
            peakAware, setPeakAware,
            forecastDate, setForecastDate,
            forecastEndDate, setForecastEndDate,
            enhancedSmoothing, setEnhancedSmoothing,
            maxDiffPct, setMaxDiffPct,
            smoothingWindow, setSmoothingWindow,
            startDate, setStartDate,
            endDate, setEndDate,
            interval, setInterval,
            realTimeAdjustment, setRealTimeAdjustment,
            onClearCache,
            modelType, setModelType,
            // Add new props for net load
            calculateNetLoad, setCalculateNetLoad 
        }) {
            // 为区间预测添加特有状态
            const [confidenceLevel, setConfidenceLevel] = useState(0.95);
            const [intervalType, setIntervalType] = useState('percentile');
            
            // Set initial province when availableProvinces loads
            useEffect(() => {
                if (availableProvinces && availableProvinces.length > 0 && !availableProvinces.includes(selectedProvince)) {
                    setSelectedProvince(availableProvinces[0]);
                }
            }, [availableProvinces]);

            const handleSubmit = (e) => {
                e.preventDefault();

                // Log values just before constructing commonParams
                console.log("[ParameterSettings.handleSubmit] Props received by component related to calculateNetLoad:", { calculateNetLoadFromProps: calculateNetLoad });
                console.log("[ParameterSettings.handleSubmit] forecastType (local state):", forecastType);
                // console.log("[ParameterSettings.handleSubmit] calculateNetLoad (prop from App):", calculateNetLoad); // Redundant due to the log above

                const commonParams = {
                    province: selectedProvince,
                    forecastType: forecastType, // This is ParameterSettings' local state for forecastType
                    historicalDays: historicalDays, 
                    modelType: modelType, 
                };
                if (forecastType === 'load') { // Check ParameterSettings' local state
                    commonParams.calculate_net_load = calculateNetLoad; // calculateNetLoad is the prop from App's state
                }

                // Include load-specific params only if forecastType is 'load'
                const loadParams = forecastType === 'load' ? {
                    peakStart,
                    peakEnd,
                    valleyStart,
                    valleyEnd,
                    peakWeight,
                    valleyWeight,
                    peakAware,
                } : {};

                let specificParams = {};
                if (type === 'day-ahead') {
                    specificParams = {
                        forecastDate,
                        forecastEndDate,
                        enhancedSmoothing,
                        maxDiffPct: enhancedSmoothing ? maxDiffPct : undefined,
                        smoothingWindow: enhancedSmoothing ? smoothingWindow : undefined,
                    };
                } else if (type === 'rolling') { // rolling
                    specificParams = {
                        startDate,
                        endDate,
                        interval,
                        realTimeAdjustment: forecastType === 'load' ? realTimeAdjustment : false, // Only for load
                    };
                } else if (type === 'interval') { // 区间预测
                    specificParams = {
                        startDate,
                        endDate,
                        interval,
                        confidenceLevel,
                        intervalType,
                        realTimeAdjustment: forecastType === 'load' ? realTimeAdjustment : false, // Only for load
                    };
                }

                onSubmit({ ...commonParams, ...loadParams, ...specificParams });
            };

            return (
                <form onSubmit={handleSubmit} className="space-y-4 fade-in">
                    {/* Forecast Type Selector */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">预测类型</label>
                        <select 
                            value={forecastType}
                            onChange={(e) => setForecastType(e.target.value)}
                            className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                        >
                            <option value="load">负荷 (Load)</option>
                            <option value="pv">光伏 (PV)</option>
                            <option value="wind">风电 (Wind)</option>
                        </select>
                    </div>
                    
                    {/* Model Type Selector */}
                    {type === 'interval' ? (
                        <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">模型类型 (区间预测)</label>
                            <select
                                value={modelType} // Prop from App
                                onChange={(e) => setModelType(e.target.value)} // Calls App's setModelType
                                className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                            >
                                <option value="peak_aware">峰值感知模型 (Peak-Aware)</option>
                                <option value="statistical">统计模型 (Statistical)</option>
                            </select>
                            <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                为区间预测选择合适的模型。推荐使用峰值感知模型。
                            </div>
                        </div>
                    ) : (
                        <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">模型类型</label>
                            <select 
                                value={modelType} // Prop from App
                                onChange={(e) => setModelType(e.target.value)} // Calls App's setModelType
                                className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                            >
                                <option value="torch">PyTorch模型</option>
                                <option value="keras">Keras模型</option>
                            </select>
                            <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                选择不同的深度学习框架模型。目前推荐使用默认的PyTorch模型。
                            </div>
                        </div>
                    )}
                    
                    {/* Province Selector */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">选择省份</label>
                        <select 
                            value={selectedProvince}
                            onChange={(e) => setSelectedProvince(e.target.value)}
                            className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                            disabled={!availableProvinces || availableProvinces.length === 0}
                        >
                            {availableProvinces && availableProvinces.length > 0 ? (
                                availableProvinces.map(p => <option key={p} value={p}>{p}</option>)
                            ) : (
                                <option>加载中...</option>
                            )}
                        </select>
                    </div>

                    {/* Dataset Configuration Section */}
                    <div className="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                        <h4 className="text-md font-semibold mb-2">数据集配置</h4>
                        <div className="grid grid-cols-1 gap-4">
                            <NumberInput 
                                label="历史数据天数 [Historical Days]" 
                                value={historicalDays} 
                                onChange={setHistoricalDays} 
                                min={1} 
                                max={30} 
                            />
                            <div className="text-sm text-gray-500 dark:text-gray-400 italic">
                                用于模型输入的历史数据天数，影响预测质量和响应时间，建议值: 7-14天
                            </div>
                        </div>
                    </div>

                    {/* Peak/Valley Settings - Only show if forecastType is 'load' */}
                    {forecastType === 'load' && (
                        <div className="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                            <h4 className="text-md font-semibold mb-2">负荷特性参数</h4>
                            <div className="flex items-center mb-4">
                                <input 
                                    type="checkbox" 
                                    id="peakAware" 
                                    checked={peakAware}
                                    onChange={(e) => setPeakAware(e.target.checked)}
                                    className="h-4 w-4 text-primary-600 border-gray-300 rounded focus:ring-primary-500"
                                />
                                <label htmlFor="peakAware" className="ml-2 block text-sm text-gray-900 dark:text-gray-100">启用高峰/低谷预测</label>
                            </div>
                            {peakAware && (
                                <div className="pl-6 border-l-2 border-primary-200 dark:border-primary-700 space-y-4">
                                    <div className="grid grid-cols-2 gap-4">
                                        <NumberInput label="高峰开始 (小时)" value={peakStart} onChange={setPeakStart} min={0} max={23} />
                                        <NumberInput label="高峰结束 (小时)" value={peakEnd} onChange={setPeakEnd} min={0} max={23} />
                                    </div>
                                    <div className="grid grid-cols-2 gap-4">
                                        <NumberInput label="低谷开始 (小时)" value={valleyStart} onChange={setValleyStart} min={0} max={23} />
                                        <NumberInput label="低谷结束 (小时)" value={valleyEnd} onChange={setValleyEnd} min={0} max={23} />
                                    </div>
                                    <div className="grid grid-cols-2 gap-4">
                                        <NumberInput label="高峰权重" value={peakWeight} onChange={setPeakWeight} min={1} max={20} step={0.1} />
                                        <NumberInput label="低谷权重" value={valleyWeight} onChange={setValleyWeight} min={1} max={20} step={0.1} />
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {/* Day-ahead Specific */}
                    {type === 'day-ahead' && (
                        <div className="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                            <h4 className="text-md font-semibold mb-2">日前预测参数</h4>
                            <DatePicker label="预测开始日期" value={forecastDate} onChange={setForecastDate} />
                            <DatePicker label="预测结束日期 (可选)" value={forecastEndDate} onChange={setForecastEndDate} min={forecastDate} />
                            <div className="text-sm text-gray-500 dark:text-gray-400 italic mb-4">
                                若不指定结束日期，则仅预测开始日期当天的数据。指定结束日期后，系统将预测从开始日期到结束日期的所有数据。
                            </div>
                        </div>
                    )}
                    
                    {/* Rolling Specific */}
                    {type === 'rolling' && (
                        <div className="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                            <h4 className="text-md font-semibold mb-2">滚动预测参数</h4>
                            <DatePicker label="起始日期" value={startDate} onChange={setStartDate} />
                            <DatePicker label="结束日期" value={endDate} onChange={setEndDate} min={startDate} />
                            <NumberInput 
                                label="预测时间间隔 (分钟)" 
                                value={interval} 
                                onChange={setInterval} 
                                min={15} 
                                max={1440} 
                                step={15}
                            />
                            {forecastType === 'load' && (
                                <div className="flex items-center mt-4">
                                    <input 
                                        type="checkbox" 
                                        id="realTimeAdjustment" 
                                        checked={realTimeAdjustment}
                                        onChange={(e) => setRealTimeAdjustment(e.target.checked)}
                                        className="h-4 w-4 text-primary-600 border-gray-300 rounded focus:ring-primary-500"
                                    />
                                    <label htmlFor="realTimeAdjustment" className="ml-2 block text-sm text-gray-900 dark:text-gray-100">
                                        实时调整 (使用最新数据调整短期预测)
                                    </label>
                                </div>
                            )}
                        </div>
                    )}
                    
                    {/* Interval Forecast Specific */}
                    {type === 'interval' && (
                        <div className="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                            <h4 className="text-md font-semibold mb-2">区间预测参数</h4>
                            <DatePicker label="起始日期" value={startDate} onChange={setStartDate} />
                            <DatePicker label="结束日期" value={endDate} onChange={setEndDate} min={startDate} />
                            <NumberInput 
                                label="预测时间间隔 (分钟)" 
                                value={interval} 
                                onChange={setInterval} 
                                min={15} 
                                max={1440} 
                                step={15}
                            />
                            
                            {/* 区间预测特有参数 */}
                            <div className="mt-4">
                                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">置信水平</label>
                                <select 
                                    value={confidenceLevel}
                                    onChange={(e) => setConfidenceLevel(parseFloat(e.target.value))}
                                    className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                                >
                                    <option value="0.80">80%</option>
                                    <option value="0.90">90%</option>
                                    <option value="0.95">95%</option>
                                    <option value="0.99">99%</option>
                                </select>
                            </div>
                            
                            <div className="mt-4">
                                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">区间类型</label>
                                <select 
                                    value={intervalType}
                                    onChange={(e) => setIntervalType(e.target.value)}
                                    className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                                >
                                    <option value="percentile">百分位数 (Percentile)</option>
                                    <option value="stdev">标准差 (Standard Deviation)</option>
                                </select>
                                <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                    百分位数方法基于历史数据的分布，标准差方法假设数据符合正态分布
                                </div>
                            </div>
                            
                            {forecastType === 'load' && (
                                <div className="flex items-center mt-4">
                                    <input 
                                        type="checkbox" 
                                        id="realTimeAdjustment" 
                                        checked={realTimeAdjustment}
                                        onChange={(e) => setRealTimeAdjustment(e.target.checked)}
                                        className="h-4 w-4 text-primary-600 border-gray-300 rounded focus:ring-primary-500"
                                    />
                                    <label htmlFor="realTimeAdjustment" className="ml-2 block text-sm text-gray-900 dark:text-gray-100">
                                        实时调整 (使用最新数据调整短期预测)
                                    </label>
                                </div>
                            )}
                        </div>
                    )}
                    
                    {/* Net Load Calculation Option - Only for load forecasts */}
                    {forecastType === 'load' && (
                        <div className="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                            <h4 className="text-md font-semibold mb-2">净负荷计算</h4>
                            <div className="flex items-center">
                                <input 
                                    type="checkbox" 
                                    id="calculateNetLoad" 
                                    checked={calculateNetLoad}
                                    onChange={(e) => setCalculateNetLoad(e.target.checked)}
                                    className="h-4 w-4 text-primary-600 border-gray-300 rounded focus:ring-primary-500"
                                />
                                <label htmlFor="calculateNetLoad" className="ml-2 block text-sm text-gray-900 dark:text-gray-100">
                                    计算并显示净负荷 (总负荷 - 光伏预测 - 风电预测)
                                </label>
                            </div>
                            <div className="text-sm text-gray-500 dark:text-gray-400 italic mt-2 ml-6">
                                勾选此项后，系统将在预测总负荷的同时，预测光伏和风电出力，并计算净负荷。
                                (注意：这会增加预测总时长，因为需要执行三次独立的预测流程。光伏和风电将使用其默认的确定性预测模型。)
                            </div>
                        </div>
                    )}

                    <div className="mt-6 flex justify-between">
                        <button
                            type="button"
                            onClick={onClearCache}
                            className="inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-700 shadow-sm text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
                        >
                            清除缓存
                        </button>
                        <button
                            type="submit"
                            disabled={isLoading}
                            className={`inline-flex items-center px-6 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white ${isLoading ? 'bg-gray-400 dark:bg-gray-600 cursor-not-allowed' : 'bg-primary-600 hover:bg-primary-700 dark:bg-primary-500 dark:hover:bg-primary-600'} focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500`}
                        >
                            {isLoading ? (
                                <>
                                    <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    处理中...
                                </>
                            ) : (
                                '开始预测'
                            )}
                        </button>
                    </div>
                </form>
            );
        }

        // 概率预测参数设置组件 (ProbabilisticSettings remains similar, potentially add onClearCache prop too if needed)
        function ProbabilisticSettings({ type, onSubmit, isLoading, availableProvinces, onClearCache }) {
            const [selectedProvince, setSelectedProvince] = useState('上海');
            const [forecastType, setForecastType] = useState('load');
            // Rename forecastDate to forecastStartDate for clarity
            const [forecastStartDate, setForecastStartDate] = useState(
                new Date(new Date().setDate(new Date().getDate() + 1)).toISOString().split('T')[0]
            );
            // Ensure forecastEndDate is initialized, also to tomorrow by default, matching start date
            const [forecastEndDate, setForecastEndDate] = useState(
                new Date(new Date().setDate(new Date().getDate() + 1)).toISOString().split('T')[0]
            );
            const [historicalDays, setHistoricalDays] = useState(8);
            const [quantiles, setQuantiles] = useState([0.1, 0.5, 0.9]);
            const [predictionMethod, setPredictionMethod] = useState('interval'); // 默认使用区间预测方法
            const [confidenceLevel, setConfidenceLevel] = useState(0.9); // 区间预测的置信水平
            const [method, setMethod] = useState('mean'); // 统计预测方法 ('mean', 'last', 'ewma')
            const [modelType, setModelType] = useState('peak_aware'); // 默认使用峰值感知模型类型
            const [isResultLoading, setIsResultLoading] = useState(false); // 加载状态
            
            // Set initial province when availableProvinces loads
            useEffect(() => {
                const staticProvinces = ['上海', '福建', '江苏', '浙江', '安徽'];
                if (!staticProvinces.includes(selectedProvince) || selectedProvince === '' ) {
                    setSelectedProvince(staticProvinces[0]);
                }
                
                // 设置默认日期为明天
                const tomorrow = new Date();
                tomorrow.setDate(tomorrow.getDate() + 1);
                const tomorrowStr = tomorrow.toISOString().split('T')[0];
                setForecastStartDate(tomorrowStr);
                setForecastEndDate(tomorrowStr);
                
                // 确保默认使用峰值感知模型
                if (predictionMethod === 'interval' && modelType !== 'peak_aware') {
                    setModelType('peak_aware');
                }
            }, []);
            
            const handleSubmit = (e) => {
                e.preventDefault();
                setIsResultLoading(true); // 开始加载
                
                // 根据预测方法选择不同的API参数
                if (predictionMethod === 'interval') {
                    // 使用区间预测API
                    // 确保日期格式正确
                    const currentDate = new Date();
                    const formattedStartDate = forecastStartDate || currentDate.toISOString().split('T')[0];
                    const formattedEndDate = forecastEndDate || formattedStartDate; // Default end date to start date if not provided
                    
                    // 准备API请求体 - 添加model_type参数
                    const requestBody = {
                        province: selectedProvince,
                        forecast_date: formattedStartDate, // Pass start date
                        forecast_end_date: formattedEndDate, // Pass end date
                        forecast_type: forecastType,
                        confidence_level: confidenceLevel,
                        model_type: 'peak_aware', // 始终使用峰值感知模型，不管UI中选择了什么
                        historical_days: historicalDays,
                        plot: true,
                        save: true
                    };
                    
                    // 只有在使用统计模型时才添加method参数
                    if (modelType === 'statistical') {
                        requestBody.method = method;
                    }
                    
                    // 在控制台显示请求信息
                    console.log("发送区间预测请求:", requestBody);
                    
                    fetch(`${API_BASE_URL}/interval-forecast`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody),
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // 显示预测结果
                            displayIntervalForecastResults(data);
                        } else {
                            // 显示错误信息
                            showErrorMessage(data.error || '预测失败');
                        }
                        setIsResultLoading(false); // 结束加载
                    })
                    .catch(error => {
                        showErrorMessage('网络请求失败: ' + error.message);
                        setIsResultLoading(false); // 结束加载
                    });
                } else {
                    // 使用常规概率预测API
                    onSubmit({
                        province: selectedProvince,
                        forecastType: forecastType,
                        forecastDate: forecastStartDate, // Use forecastStartDate for quantile too
                        forecastEndDate: forecastEndDate, // Use forecastEndDate for quantile too
                        historicalDays: historicalDays,
                        probabilistic: true,
                        quantiles: quantiles
                    });
                }
            };
            
            // 新增：显示区间预测结果
            const displayIntervalForecastResults = (data) => {
                // 创建预测区间图表的容器
                const chartContainer = document.getElementById('probabilistic-chart-container');
                if (!chartContainer) return;
                
                // 清空图表容器
                chartContainer.innerHTML = '<canvas id="interval-forecast-chart"></canvas>';
                
                // 绘制图表
                const ctx = document.getElementById('interval-forecast-chart').getContext('2d');
                
                // 准备数据
                const chartData = {
                    labels: data.times,
                    datasets: [
                        {
                            label: '预测值',
                            data: data.prediction,
                            borderColor: 'rgb(54, 162, 235)',
                            backgroundColor: 'rgba(54, 162, 235, 0.5)',
                            borderWidth: 2,
                            fill: false
                        }
                    ]
                };
                
                // 如果有实际值，添加到图表
                if (data.actual && data.actual.some(v => v !== null)) {
                    chartData.datasets.push({
                        label: '实际值',
                        data: data.actual,
                        borderColor: 'rgb(255, 0, 0)',  // 鲜艳的纯红色
                        backgroundColor: 'rgba(255, 0, 0, 0.7)',  // 更鲜明的红色背景
                        borderWidth: 3,  // 更粗的线
                        pointRadius: 5,  // 更大的点
                        pointHoverRadius: 7,  // 悬停时更大的点
                        fill: false
                    });
                    
                    // 在控制台输出实际值信息，帮助调试
                    const validActualValues = data.actual.filter(v => v !== null);
                    console.log(`包含 ${validActualValues.length} 个有效实际值点`);
                    console.log(`实际值样例: ${validActualValues.slice(0, 5).join(', ')}`);
                }
                
                // 添加上下限
                if (data.lower_bound && data.upper_bound) {
                    chartData.datasets.push({
                        label: '下限',
                        data: data.lower_bound,
                        borderColor: 'rgba(255, 159, 64, 0.8)',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0
                    });
                    
                    chartData.datasets.push({
                        label: '上限',
                        data: data.upper_bound,
                        borderColor: 'rgba(255, 159, 64, 0.8)',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: '+1', // 填充到下限
                        backgroundColor: 'rgba(255, 159, 64, 0.2)',
                        pointRadius: 0
                    });
                }
                
                // 创建图表
                new Chart(ctx, {
                    type: 'line',
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    // 自定义工具提示显示
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += new Intl.NumberFormat('zh-CN').format(context.parsed.y);
                                        }
                                        return label;
                                    }
                                }
                            },
                            legend: {
                                position: 'top',
                            }
                        },
                        scales: {
                            x: {
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                beginAtZero: false
                            }
                        }
                    }
                });
                
                // 显示预测结果区块
                document.getElementById('probabilistic-results').classList.remove('hidden');
                
                // 隐藏加载指示器
                document.getElementById('probabilistic-loading').classList.add('hidden');
                
                // 更新预测标题
                const typeLabels = { 'load': '负荷', 'pv': '光伏', 'wind': '风电' };
                const methodLabels = { 'mean': '均值法', 'last': '最近值法', 'ewma': '指数加权移动平均法' };
                const modelTypeLabels = { 'statistical': '统计模型', 'peak_aware': '峰值感知模型' };
                const titleElement = document.getElementById('probabilistic-forecast-title');
                
                // Access data from the correct nested object (data.data)
                const province = data.data.province;
                const forecastTypeDisplay = data.data.forecast_type;
                const modelTypeDisplay = data.data.model_type;
                const methodDisplay = data.data.method;
                let forecastPeriod = data.data.date; // Default to single date

                // Check if it's a date range
                if (data.data.forecast_start_date && data.data.forecast_end_date && data.data.forecast_start_date !== data.data.forecast_end_date) {
                    forecastPeriod = `${data.data.forecast_start_date} 至 ${data.data.forecast_end_date}`;
                }
                
                if (titleElement) {
                    let titleText = `${province || '未知省份'} ${typeLabels[forecastTypeDisplay] || '未知类型'} 区间预测`;
                    if (forecastPeriod) {
                        titleText += ` (${forecastPeriod})`;
                    }
                    titleText += ` - ${modelTypeLabels[modelTypeDisplay] || '未知模型'}`;
                    if (modelTypeDisplay !== 'peak_aware' && methodDisplay && methodLabels[methodDisplay]) {
                        titleText += `(${methodLabels[methodDisplay]})`;
                    }
                    titleElement.textContent = titleText;
                }
                
                // 如果有实际值，在标题中加入说明
                if (data.actual && data.actual.some(v => v !== null)) {
                    if (titleElement) titleElement.textContent += " [包含真实值]";
                }
                
                // 显示区间统计信息
                const intervalStats = document.getElementById('interval-stats');
                if (intervalStats) {
                    intervalStats.classList.remove('hidden');
                    
                    // 更新置信水平
                    document.getElementById('confidence-display').textContent = `${Math.round(confidenceLevel * 100)}%`;
                    
                    // 计算平均区间宽度
                    const widths = data.upper_bound.map((upper, i) => upper - data.lower_bound[i]);
                    const avgWidth = widths.reduce((sum, width) => sum + width, 0) / widths.length;
                    document.getElementById('interval-width').textContent = avgWidth.toFixed(2);
                    
                    // 计算实际值落入区间的比例
                    if (data.actual && data.actual.some(v => v !== null)) {
                        const validPoints = data.actual.filter(v => v !== null).length;
                        console.log(`发现${validPoints}个有效的实际值数据点`);
                        let hitsCount = 0;
                        
                        for (let i = 0; i < data.actual.length; i++) {
                            if (data.actual[i] !== null) {
                                if (data.actual[i] >= data.lower_bound[i] && data.actual[i] <= data.upper_bound[i]) {
                                    hitsCount++;
                                }
                            }
                        }
                        
                        const hitRate = validPoints > 0 ? (hitsCount / validPoints) * 100 : 0;
                        document.getElementById('hit-rate').textContent = `${hitRate.toFixed(1)}% (${hitsCount}/${validPoints})`;
                        
                        // 设置明确的命中率标签
                        document.getElementById('hit-rate-label').textContent = "实际值命中率";
                    } else {
                        document.getElementById('hit-rate').textContent = '无实际值';
                        document.getElementById('hit-rate-label').textContent = "实际值命中率(无数据)";
                    }
                }
                
                // 滚动到结果区域
                setTimeout(() => {
                    const resultsElement = document.getElementById('probabilistic-results');
                    if (resultsElement) {
                        resultsElement.scrollIntoView({ behavior: 'smooth' });
                    }
                }, 300);
            };
            
            // 新增：显示错误信息
            const showErrorMessage = (message) => {
                // 隐藏加载指示器
                document.getElementById('probabilistic-loading').classList.add('hidden');
                
                // 显示错误信息
                const errorElement = document.getElementById('probabilistic-error');
                const errorMessageElement = document.getElementById('probabilistic-error-message');
                
                if (errorElement && errorMessageElement) {
                    errorElement.classList.remove('hidden');
                    errorMessageElement.textContent = message;
                } else {
                    alert('预测失败: ' + message);
                }
            };
            
            const handleQuantileChange = (index, value) => {
                const newQuantiles = [...quantiles];
                newQuantiles[index] = parseFloat(value);
                setQuantiles(newQuantiles);
            };
            
            const addQuantile = () => {
                if (quantiles.length < 9) {
                    setQuantiles([...quantiles, 0.5]);
                }
            };
            
            const removeQuantile = (index) => {
                if (quantiles.length > 1) {
                    const newQuantiles = [...quantiles];
                    newQuantiles.splice(index, 1);
                    setQuantiles(newQuantiles);
                }
            };
            
            return (
                <form onSubmit={handleSubmit} className="space-y-4 fade-in">
                    {/* Forecast Type Selector */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">预测类型</label>
                        <select 
                            value={forecastType}
                            onChange={(e) => setForecastType(e.target.value)}
                            className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                        >
                            <option value="load">负荷 (Load)</option>
                            <option value="pv">光伏 (PV)</option>
                            <option value="wind">风电 (Wind)</option>
                        </select>
                    </div>
                    
                    {/* Province Selector */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">选择省份</label>
                        <select 
                            value={selectedProvince}
                            onChange={(e) => setSelectedProvince(e.target.value)}
                            className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                        >
                            {availableProvinces && availableProvinces.length > 0 ? (
                                availableProvinces.map(p => <option key={p} value={p}>{p}</option>)
                            ) : (
                                ['上海', '福建', '江苏', '浙江', '安徽'].map(p => <option key={p} value={p}>{p}</option>)
                            )}
                        </select>
                    </div>

                    {/* 预测方法选择器 */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">预测方法</label>
                        <select 
                            value={predictionMethod}
                            onChange={(e) => setPredictionMethod(e.target.value)}
                            className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                        >
                            <option value="interval">区间预测</option>
                            <option value="quantile">分位数预测</option>
                        </select>
                        <div className="mt-1 text-sm text-gray-500 dark:text-gray-400 italic">
                            {predictionMethod === 'interval' ? 
                             '区间预测：基于多模型集成和误差分布，生成最优宽度的预测区间' : 
                             '分位数预测：使用分位数损失训练模型，直接预测不同分位数的值'}
                        </div>
                    </div>

                    {/* Dataset Configuration Section */}
                    <div className="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                        <h4 className="text-md font-semibold mb-2">数据集配置</h4>
                        <div className="grid grid-cols-1 gap-4">
                            <NumberInput 
                                label="历史数据天数 [Historical Days]" 
                                value={historicalDays} 
                                onChange={setHistoricalDays} 
                                min={1} 
                                max={30} 
                            />
                            <div className="text-sm text-gray-500 dark:text-gray-400 italic">
                                用于模型输入的历史数据天数，影响预测质量和响应时间，建议值: 7-14天
                            </div>
                        </div>
                    </div>

                    {/* 概率预测参数 - 根据预测方法显示不同内容 */}
                    <div className="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                        <h4 className="text-md font-semibold mb-2">
                            {predictionMethod === 'interval' ? '区间预测参数' : '概率预测参数'}
                        </h4>
                        
                        {predictionMethod === 'interval' ? (
                            // 区间预测参数
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                                        置信水平: {Math.round(confidenceLevel * 100)}%
                                    </label>
                                    <input 
                                        type="range" 
                                        min="50" 
                                        max="99" 
                                        step="1" 
                                        value={confidenceLevel * 100} 
                                        onChange={(e) => setConfidenceLevel(parseInt(e.target.value) / 100)}
                                        className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700"
                                    />
                                    <div className="flex justify-between text-xs text-gray-500 dark:text-gray-400 mt-1">
                                        <span>50%</span>
                                        <span>70%</span>
                                        <span>90%</span>
                                        <span>99%</span>
                                    </div>
                                </div>
                                
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">预测模型类型</label>
                                    <select 
                                        value={modelType}
                                        onChange={(e) => setModelType(e.target.value)}
                                        className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                                    >
                                        <option value="statistical">统计模型 (Statistical)</option>
                                        <option value="peak_aware">峰值感知模型 (Peak-Aware)</option>
                                    </select>
                                    <div className="mt-1 text-sm text-gray-500 dark:text-gray-400 italic">
                                        峰值感知模型能够识别负荷高峰和低谷，对15分钟级别的预测表现更好
                                    </div>
                                </div>
                                
                                {modelType === 'statistical' && (
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">统计预测算法</label>
                                    <select 
                                        value={method}
                                        onChange={(e) => setMethod(e.target.value)}
                                        className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                                    >
                                        <option value="mean">均值法 (Mean)</option>
                                        <option value="last">最近值法 (Last Value)</option>
                                        <option value="ewma">指数加权移动平均法 (EWMA)</option>
                                    </select>
                                    <div className="mt-1 text-sm text-gray-500 dark:text-gray-400 italic">
                                        不同算法适用于不同场景，均值法稳定性好，EWMA对最近数据更敏感
                                    </div>
                                </div>
                                )}
                            </div>
                        ) : (
                            // 分位数预测参数
                            <div>
                                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">分位数集合</label>
                                {quantiles.map((q, index) => (
                                    <div key={index} className="flex items-center space-x-2 mb-2">
                                        <input 
                                            type="number" 
                                            value={q} 
                                            min={0.01} 
                                            max={0.99} 
                                            step={0.01}
                                            onChange={(e) => handleQuantileChange(index, e.target.value)}
                                            className="w-24 px-2 py-1 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm bg-white dark:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                                        />
                                        <span className="text-sm text-gray-500 dark:text-gray-400">
                                            {Math.round(q * 100)}%分位数
                                        </span>
                                        {quantiles.length > 1 && (
                                            <button 
                                                type="button" 
                                                onClick={() => removeQuantile(index)}
                                                className="text-red-500 hover:text-red-700"
                                            >
                                                <span className="material-icons text-sm">remove_circle</span>
                                            </button>
                                        )}
                                    </div>
                                ))}
                                {quantiles.length < 9 && (
                                    <button 
                                        type="button" 
                                        onClick={addQuantile}
                                        className="mt-2 text-sm text-primary-600 dark:text-primary-400 hover:text-primary-700 flex items-center"
                                    >
                                        <span className="material-icons text-sm mr-1">add_circle</span> 添加分位数
                                    </button>
                                )}
                            </div>
                        )}
                    </div>

                    {/* Forecast Date Parameters */}
                    <div className="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                        <h4 className="text-md font-semibold mb-2">预测日期参数</h4>
                        <DatePicker label="预测开始日期" value={forecastStartDate} onChange={setForecastStartDate} />
                        {/* Always show forecastEndDate, its relevance depends on predictionMethod or API logic */}
                        <DatePicker label="预测结束日期 (可选)" value={forecastEndDate} onChange={setForecastEndDate} min={forecastStartDate} />
                        <div className="text-sm text-gray-500 dark:text-gray-400 italic mb-4">
                            {predictionMethod === 'interval' ? 
                             '对于区间预测，如果结束日期与开始日期不同，将预测该范围内的每一天。' :
                             '对于分位数预测，如果结束日期与开始日期不同，将预测该范围内的每一天。'}
                             若结束日期与开始日期相同或未指定结束日期，则仅预测单日。
                        </div>
                    </div>

                    {/* Submit Button */}
                    <div className="pt-4 space-y-2">
                        <button
                            type="submit"
                            disabled={isLoading || isResultLoading}
                            className={`w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 ${(isLoading || isResultLoading) ? 'opacity-50 cursor-not-allowed' : ''}`}
                        >
                            {isResultLoading ? (
                                <>
                                    <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    预测中...
                                </>
                            ) : (
                                predictionMethod === 'interval' ? '开始区间预测' : '开始概率预测'
                            )}
                        </button>
                        <button
                            type="button"
                            onClick={onClearCache}
                            className="w-full flex justify-center items-center py-2 px-4 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-200 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 btn-hover"
                        >
                           <span className="material-icons text-base mr-1">delete_sweep</span> 清除API缓存
                        </button>
                    </div>
                    
                    {/* 区间预测结果显示区域 */}
                    <div id="probabilistic-results" className="mt-6 hidden">
                        <h4 id="probabilistic-forecast-title" className="text-lg font-semibold mb-4">区间预测结果</h4>
                        
                        {/* 区间统计信息 */}
                        <div id="interval-stats" className="grid grid-cols-3 gap-4 mb-4 hidden">
                            <div className="bg-blue-50 dark:bg-blue-900/30 rounded-lg p-3 text-center">
                                <p className="text-sm text-gray-600 dark:text-gray-400">置信水平</p>
                                <p id="confidence-display" className="text-lg font-semibold text-blue-600 dark:text-blue-400">90%</p>
                            </div>
                            <div className="bg-green-50 dark:bg-green-900/30 rounded-lg p-3 text-center">
                                <p className="text-sm text-gray-600 dark:text-gray-400">平均区间宽度</p>
                                <p id="interval-width" className="text-lg font-semibold text-green-600 dark:text-green-400">0.00</p>
                            </div>
                            <div className="bg-amber-50 dark:bg-amber-900/30 rounded-lg p-3 text-center">
                                <p id="hit-rate-label" className="text-sm text-gray-600 dark:text-gray-400">区间覆盖率</p>
                                <p id="hit-rate" className="text-lg font-semibold text-amber-600 dark:text-amber-400">N/A</p>
                            </div>
                        </div>
                        
                        {/* 图表容器 */}
                        <div id="probabilistic-chart-container" className="h-80 w-full"></div>
                    </div>
                    
                    {/* 错误信息 */}
                    <div id="probabilistic-error" className="mt-4 bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400 p-4 rounded-lg hidden">
                        <div className="flex items-center">
                            <span className="material-icons mr-2">error</span>
                            <p id="probabilistic-error-message">预测失败</p>
                        </div>
                    </div>
                    
                    {/* 加载指示器 */}
                    <div id="probabilistic-loading" className="hidden flex justify-center items-center py-8">
                        <svg className="animate-spin h-8 w-8 text-primary-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <p className="ml-3 text-primary-600 dark:text-primary-400">加载预测结果...</p>
                    </div>
                </form>
            );
        }

        // 训练参数设置组件 (TrainingSettings remains similar, potentially add onClearCache prop too if needed)
        function TrainingSettings({ onSubmit, isLoading, onClearCache, onUnifiedSubmit }) {
            // Training State
            const [provinces, setProvinces] = useState([]);
            const [province, setProvince] = useState('');
            const [trainStartDate, setTrainStartDate] = useState('2024-01-01');
            const [trainEndDate, setTrainEndDate] = useState('2024-01-30');
            const [epochs, setEpochs] = useState(10);
            const [batchSize, setBatchSize] = useState(32);
            const [learningRate, setLearningRate] = useState(0.0001);
            const [forecastType, setForecastType] = useState('load');
            const [retrain, setRetrain] = useState(false);
            // --- 新增：训练目标类型状态 ---
            const [trainPredictionType, setTrainPredictionType] = useState('deterministic'); // 'deterministic', 'probabilistic', 'interval'
            // --- 新增：分位数状态 (仅用于概率预测) ---
            const [quantiles, setQuantiles] = useState([0.1, 0.5, 0.9]);
            // ------------------------------
            
            // Dataset Configuration
            const [historicalDays, setHistoricalDays] = useState(8);
            
            // Load-specific settings
            const [peakAware, setPeakAware] = useState(true);
            const [peakStart, setPeakStart] = useState(7);
            const [peakEnd, setPeakEnd] = useState(22);
            const [valleyStart, setValleyStart] = useState(0);
            const [valleyEnd, setValleyEnd] = useState(6);
            const [peakWeight, setPeakWeight] = useState(10.0);
            const [valleyWeight, setValleyWeight] = useState(1.5);
            // --- 新增：模型框架状态 ---
            const [modelFramework, setModelFramework] = useState('torch'); // 'torch' or 'keras'
            // ------------------------

            // Fetch provinces on mount (using static list)
            useEffect(() => {
                const staticProvinces = ['上海', '福建', '江苏', '浙江', '安徽'];
                setProvinces(staticProvinces);
                if (!staticProvinces.includes(province) || province === '') {
                    setProvince(staticProvinces[0]);
                }
            }, []);

            const handleSubmit = (e) => {
                e.preventDefault();
                
                let finalProvince = province;
                if (!finalProvince || finalProvince === '') {
                    if (provinces.length > 0) {
                        finalProvince = provinces[0];
                    } else {
                        finalProvince = '上海';
                    }
                }
                
                const commonParams = {
                    province: finalProvince,
                    forecast_type: forecastType,
                    train_start: trainStartDate,
                    train_end: trainEndDate,
                    epochs: parseInt(epochs),
                    batch_size: parseInt(batchSize),
                    learning_rate: parseFloat(learningRate),
                    retrain: retrain,
                    historical_days: historicalDays,
                    model_framework: modelFramework, // 传递模型框架
                    // --- 传递训练目标类型 --- 
                    train_prediction_type: trainPredictionType,
                    // ------------------------
                };

                // --- 添加特定于训练类型的参数 ---
                let specificParams = {};
                if (trainPredictionType === 'deterministic') {
                    if (forecastType === 'load') { // 峰谷感知仅用于负荷确定性预测
                         specificParams = {
                             peak_aware: peakAware,
                             ...(peakAware && {
                                peak_start: peakStart,
                                peak_end: peakEnd,
                                valley_start: valleyStart,
                                valley_end: valleyEnd,
                                peak_weight: peakWeight,
                                valley_weight: valleyWeight,
                             })
                         };
                     } else {
                         specificParams = { peak_aware: false };
                     }
                } else if (trainPredictionType === 'probabilistic') {
                    specificParams = {
                        quantiles: quantiles, // 传递分位数
                        peak_aware: peakAware // 概率模型也可能使用峰谷特征
                    };
                } else if (trainPredictionType === 'interval') {
                     specificParams = {
                         peak_aware: peakAware // 区间模型基于峰谷感知
                     };
                }
                // -------------------------------

                onSubmit({ ...commonParams, ...specificParams });
            };

            // 分位数处理函数
            const handleQuantileChange = (index, value) => {
                const newQuantiles = [...quantiles];
                const numValue = parseFloat(value);
                if (!isNaN(numValue) && numValue > 0 && numValue < 1) {
                    newQuantiles[index] = numValue;
                    setQuantiles(newQuantiles.sort((a, b) => a - b)); // 保持排序
                }
            };
            const addQuantile = () => {
                if (quantiles.length < 5) { // 限制最多5个
                    setQuantiles([...quantiles, 0.5].sort((a, b) => a - b));
                }
            };
            const removeQuantile = (index) => {
                if (quantiles.length > 1) {
                    const newQuantiles = [...quantiles];
                    newQuantiles.splice(index, 1);
                    setQuantiles(newQuantiles);
                }
            };

            // Function to determine button text
            const getButtonText = () => {
                let typeText = '负荷';
                if (forecastType === 'pv') typeText = '光伏';
                if (forecastType === 'wind') typeText = '风电';
                
                let targetText = '确定性';
                if (trainPredictionType === 'probabilistic') targetText = '概率(分位数)';
                if (trainPredictionType === 'interval') targetText = '区间';
                
                let modelText = (forecastType === 'load' && peakAware) ? '峰谷感知' : '通用';
                // 区间和概率模型也可能用峰谷特征，但按钮文本简化
                if (trainPredictionType !== 'deterministic') modelText = ''; 
                
                return `开始${typeText} ${targetText}${modelText} 模型训练`;
            };

            // New handler for the unified training button
            const handleUnifiedTrain = () => {
                let finalProvince = province;
                if (!finalProvince || finalProvince === '') {
                    if (provinces.length > 0) {
                        finalProvince = provinces[0];
                    } else {
                        finalProvince = '上海'; // Fallback if provinces list is empty
                    }
                }

                const commonParamsForUnified = {
                    province: finalProvince,
                    train_start: trainStartDate,
                    train_end: trainEndDate,
                    epochs: parseInt(epochs),
                    batch_size: parseInt(batchSize),
                    learning_rate: parseFloat(learningRate),
                    retrain: retrain,
                    historical_days: historicalDays,
                    model_framework: modelFramework,
                    // For load, use the UI settings for train_prediction_type and peak_aware
                    // These will be overridden for pv/wind inside the App component's handler
                    train_prediction_type: trainPredictionType, 
                    peak_aware: peakAware,
                    ...(peakAware && forecastType === 'load' && trainPredictionType === 'deterministic' && {
                        peak_start: peakStart,
                        peak_end: peakEnd,
                        valley_start: valleyStart,
                        valley_end: valleyEnd,
                        peak_weight: peakWeight,
                        valley_weight: valleyWeight,
                    }),
                    // Pass quantiles if probabilistic for load
                    ...(trainPredictionType === 'probabilistic' && {
                        quantiles: quantiles
                    })
                };
                onUnifiedSubmit(commonParamsForUnified);
            };

            return (
                <form onSubmit={handleSubmit} className="space-y-4 fade-in">
                     {/* Model Framework Selector */}
                     <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">模型框架</label>
                        <select
                            value={modelFramework}
                            onChange={(e) => setModelFramework(e.target.value)}
                            className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                        >
                            <option value="torch">PyTorch (推荐)</option>
                            <option value="keras">Keras (待集成)</option>
                        </select>
                    </div>
                     
                     {/* Forecast Type Selector */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">训练数据类型</label>
                        <select
                            value={forecastType}
                            onChange={(e) => setForecastType(e.target.value)}
                            className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                        >
                            <option value="load">负荷 (Load)</option>
                            <option value="pv">光伏 (PV)</option>
                            <option value="wind">风电 (Wind)</option>
                        </select>
                    </div>

                    {/* --- 新增：训练目标类型选择器 --- */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">训练目标类型</label>
                        <select
                            value={trainPredictionType}
                            onChange={(e) => setTrainPredictionType(e.target.value)}
                            className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                        >
                            <option value="deterministic">确定性预测 (点预测)</option>
                            <option value="probabilistic">概率预测 (分位数)</option>
                            <option value="interval">区间预测 (误差分布)</option>
                        </select>
                    </div>
                    {/* ------------------------------ */}

                    {/* Province Selector */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">选择省份</label>
                        <select
                            value={province}
                            onChange={(e) => setProvince(e.target.value)}
                            className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                            disabled={provinces.length === 0}
                            data-testid="training-province-select"
                        >
                            {provinces.length > 0 ? (
                                provinces.map(p => <option key={p} value={p}>{p}</option>)
                            ) : (
                                <option>加载中...</option>
                            )}
                        </select>
                    </div>
                    
                    {/* Dataset Configuration Section */}
                    <div className="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                        <h4 className="text-md font-semibold mb-2">数据集配置</h4>
                        <div className="grid grid-cols-1 gap-4">
                            <NumberInput 
                                label="历史数据天数 [Historical Days]" 
                                value={historicalDays} 
                                onChange={setHistoricalDays} 
                                min={7} // 建议至少7天 
                                max={365} 
                            />
                            <div className="text-sm text-gray-500 dark:text-gray-400 italic">
                                用于模型训练的历史数据天数，影响模型能够学习的时间模式范围，建议值: 30-90天。
                            </div>
                            <DatePicker label="训练开始日期" value={trainStartDate} onChange={setTrainStartDate} />
                            <DatePicker label="训练结束日期" value={trainEndDate} onChange={setTrainEndDate} min={trainStartDate} />
                        </div>
                    </div>

                    {/* Common Training Params */}
                    <div className="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                         <h4 className="text-md font-semibold mb-2">通用训练参数</h4>
                         <div className="grid grid-cols-2 gap-4">
                              <NumberInput label="训练轮数 (Epochs)" value={epochs} onChange={setEpochs} min={1} max={500} />
                              <NumberInput label="批处理大小 (Batch Size)" value={batchSize} onChange={setBatchSize} min={4} max={128} />
                         </div>
                         <div className="mt-4">
                            <NumberInput label="学习率 (Learning Rate)" value={learningRate} onChange={setLearningRate} min={1e-6} max={1e-2} step="any" />
                         </div>
                         <div className="flex items-center mt-4">
                              <input
                                   type="checkbox"
                                   id="retrain"
                                   checked={retrain}
                                   onChange={(e) => setRetrain(e.target.checked)}
                                   className="h-4 w-4 text-primary-600 border-gray-300 rounded focus:ring-primary-500"
                              />
                              <label htmlFor="retrain" className="ml-2 block text-sm text-gray-900 dark:text-gray-100">重新训练 (覆盖现有模型)</label>
                         </div>
                    </div>

                    {/* --- 根据训练目标类型显示特定参数 --- */}
                    {trainPredictionType === 'probabilistic' && (
                        <div className="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                             <h4 className="text-md font-semibold mb-2">概率预测参数</h4>
                             <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">分位数集合 (Quantiles)</label>
                             {quantiles.map((q, index) => (
                                <div key={index} className="flex items-center space-x-2 mb-2">
                                    <input 
                                        type="number" 
                                        value={q} 
                                        min={0.01} 
                                        max={0.99} 
                                        step={0.01}
                                        onChange={(e) => handleQuantileChange(index, e.target.value)}
                                        className="w-24 px-2 py-1 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm bg-white dark:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                                    />
                                    <span className="text-sm text-gray-500 dark:text-gray-400">
                                        {Math.round(q * 100)}%分位数
                                    </span>
                                    {quantiles.length > 1 && (
                                        <button 
                                            type="button" 
                                            onClick={() => removeQuantile(index)}
                                            className="text-red-500 hover:text-red-700"
                                            aria-label="移除分位数"
                                        >
                                            <span className="material-icons text-sm">remove_circle</span>
                                        </button>
                                    )}
                                </div>
                             ))}
                             {quantiles.length < 5 && (
                                <button 
                                    type="button" 
                                    onClick={addQuantile}
                                    className="mt-2 text-sm text-primary-600 dark:text-primary-400 hover:text-primary-700 flex items-center"
                                >
                                    <span className="material-icons text-sm mr-1">add_circle</span> 添加分位数
                                </button>
                             )}
                        </div>
                    )}

                    {/* 负荷特性参数 (确定性或区间预测且为负荷类型时显示) */}
                    {(trainPredictionType === 'deterministic' || trainPredictionType === 'interval') && forecastType === 'load' && (
                        <div className="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                            <h4 className="text-md font-semibold mb-2">负荷特性参数 (用于峰谷感知)</h4>
                             <div className="flex items-center mb-4">
                                <input
                                    type="checkbox"
                                    id="trainPeakAware"
                                    checked={peakAware}
                                    onChange={(e) => setPeakAware(e.target.checked)}
                                    className="h-4 w-4 text-primary-600 border-gray-300 rounded focus:ring-primary-500"
                                />
                                <label htmlFor="trainPeakAware" className="ml-2 block text-sm text-gray-900 dark:text-gray-100">启用峰谷感知特征/损失</label>
                            </div>
                            {peakAware && (
                                <div className="grid grid-cols-2 gap-4 pl-6 border-l-2 border-primary-200 dark:border-primary-700">
                                    <NumberInput label="高峰开始 (小时)" value={peakStart} onChange={setPeakStart} min={0} max={23} />
                                    <NumberInput label="高峰结束 (小时)" value={peakEnd} onChange={setPeakEnd} min={0} max={23} />
                                    <NumberInput label="低谷开始 (小时)" value={valleyStart} onChange={setValleyStart} min={0} max={23} />
                                    <NumberInput label="低谷结束 (小时)" value={valleyEnd} onChange={setValleyEnd} min={0} max={23} />
                                    {/* 权重仅在确定性预测时有意义 (影响损失) */}
                                    {trainPredictionType === 'deterministic' && (
                                        <>
                                            <NumberInput label="高峰权重 (损失)" value={peakWeight} onChange={setPeakWeight} min={1} max={20} step={0.1} />
                                            <NumberInput label="低谷权重 (损失)" value={valleyWeight} onChange={setValleyWeight} min={1} max={20} step={0.1} />
                                        </>
                                    )}
                                </div>
                            )}
                        </div>
                    )}
                    {/* ------------------------------------ */}

                    {/* Submit and Clear Cache Buttons */}
                     <div className="pt-4 space-y-2">
                        <button
                            type="submit"
                            disabled={isLoading}
                             className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md disabled:opacity-50 disabled:cursor-not-allowed transition-colors btn-hover"
                         >
                             {isLoading ? '训练中...' : getButtonText()}
                        </button>
                        {/* New Button for Unified Training */}
                        <button
                            type="button"
                            onClick={handleUnifiedTrain}
                            disabled={isLoading} // Disable if any training is in progress
                            className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md disabled:opacity-50 disabled:cursor-not-allowed transition-colors btn-hover mt-2"
                        >
                            {isLoading ? '处理中...' : `一键训练 ${province || '当前省份'} 所有能源类型模型`}
                        </button>
                         <button
                            type="button"
                            onClick={onClearCache} // Use the prop here too
                            className="w-full flex justify-center items-center py-2 px-4 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-200 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 btn-hover"
                        >
                           <span className="material-icons text-base mr-1">delete_sweep</span> 清除API缓存
                        </button>
                    </div>
                 </form>
            );
        }

        // 训练进度展示组件 (Restoring the component definition)
        function TrainingMonitor({ trainingData }) {
            const [trainingStatus, setTrainingStatus] = useState(trainingData);
            const [statusPollingInterval, setStatusPollingInterval] = useState(null);
            const theme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';

            // 定期轮询训练状态的函数
            useEffect(() => {
                // 如果有正在进行的训练，启动定期轮询
                if (trainingData && trainingData.trainingTaskId && trainingData.status === 'training') {
                    // 清除任何现有的轮询
                    if (statusPollingInterval) {
                        clearInterval(statusPollingInterval);
                    }

                    // 创建新的轮询
                    const interval = setInterval(() => {
                        fetchTrainingStatus(trainingData.trainingTaskId);
                    }, 3000); // 每3秒轮询一次

                    setStatusPollingInterval(interval);

                    // 组件卸载时清除轮询
                    return () => {
                        if (interval) {
                            clearInterval(interval);
                        }
                    };
                } else if (statusPollingInterval) {
                    // 如果训练已完成或失败，停止轮询
                    clearInterval(statusPollingInterval);
                    setStatusPollingInterval(null);
                }
            }, [trainingData]);

            // 获取训练状态
            const fetchTrainingStatus = async (taskId) => {
                try {
                    const response = await fetch(`${API_BASE_URL}/training-status?taskId=${taskId}`);
                    if (response.ok) {
                        const data = await response.json();
                        setTrainingStatus(data);
                        
                        // 如果训练完成或失败，停止轮询
                        if (data.status === 'completed' || data.status === 'failed') {
                            if (statusPollingInterval) {
                                clearInterval(statusPollingInterval);
                                setStatusPollingInterval(null);
                            }
                        }
                    } else {
                        console.error('Failed to fetch training status');
                    }
                } catch (error) {
                    console.error('Error fetching training status:', error);
                }
            };

            if (!trainingData) {
                return (
                    <div className="bg-slate-100 dark:bg-slate-800 rounded-lg p-4 mb-4">
                        <p className="text-slate-500 dark:text-slate-400">未开始训练</p>
                    </div>
                );
            }

            // 使用最新的训练状态
            const { currentEpoch, totalEpochs, trainingLoss, validationLoss, status } = trainingStatus || trainingData;

            // 格式化损失值
            const formatLoss = (loss) => {
                if (loss === undefined || loss === null) return 'N/A';
                return loss.toFixed(6);
            };

            // 计算进度百分比
            const progressPercentage = Math.floor((currentEpoch / totalEpochs) * 100);

            let statusTextClass = '';
            let statusBgClass = '';
            
            // 根据状态设置样式
            if (status === 'completed') {
                statusTextClass = 'text-green-700 dark:text-green-500';
                statusBgClass = 'bg-green-100 dark:bg-green-900/30';
            } else if (status === 'failed') {
                statusTextClass = 'text-red-700 dark:text-red-500';
                statusBgClass = 'bg-red-100 dark:bg-red-900/30';
            } else {
                statusTextClass = 'text-blue-700 dark:text-blue-500';
                statusBgClass = 'bg-blue-100 dark:bg-blue-900/30 dark:text-blue-400';
            }

            // 准备训练图表数据
            // --- 添加安全检查，确保 trainingLoss 和 validationLoss 是数组 --- 
            const safeTrainingLoss = Array.isArray(trainingLoss) ? trainingLoss : [];
            const safeValidationLoss = Array.isArray(validationLoss) ? validationLoss : [];
            // -------------------------------------------------------------
            
            const chartData = {
                // --- 使用安全的数组 --- 
                labels: Array.from({ length: Math.max(safeTrainingLoss.length, safeValidationLoss.length) }, (_, i) => i + 1),
                datasets: [
                    {
                        label: '训练损失',
                        data: safeTrainingLoss, // 使用 safeTrainingLoss
                        borderColor: '#2563eb', // Blue
                        backgroundColor: 'rgba(37, 99, 235, 0.1)',
                        borderWidth: 1.5,
                        tension: 0.1,
                        pointRadius: 1,
                    },
                    {
                        label: '验证损失',
                        data: safeValidationLoss, // 使用 safeValidationLoss
                        borderColor: '#e11d48', // Red
                        backgroundColor: 'rgba(225, 29, 72, 0.1)',
                        borderWidth: 1.5,
                        tension: 0.1,
                        pointRadius: 1,
                    }
                ]
            };

            const chartOptions = useMemo(() => ({
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                scales: {
                    y: {
                        beginAtZero: false,
                        title: { display: true, text: '损失' },
                         ticks: { color: document.documentElement.classList.contains('dark') ? '#cbd5e1' : '#64748b' },
                         grid: { color: document.documentElement.classList.contains('dark') ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' }
                    },
                    x: {
                        title: { display: true, text: 'Epoch' },
                         ticks: { color: document.documentElement.classList.contains('dark') ? '#cbd5e1' : '#64748b' },
                         grid: { color: document.documentElement.classList.contains('dark') ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' }
                    }
                },
                plugins: {
                    legend: { 
                        position: 'top', 
                        labels: { color: document.documentElement.classList.contains('dark') ? '#f1f5f9' : '#334155' }
                     },
                    tooltip: { mode: 'index', intersect: false },
                },
                 animation: { duration: 500 }
            }), []); // Dependencies might be needed if colors change with theme toggle live

            // 渲染图表
            const renderChart = () => {
                if (Line) {
                    return <Line data={chartData} options={chartOptions} />;
                } else {
                    return <ChartComponent type="line" data={chartData} options={chartOptions} />;
                }
            };

            return (
                <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 fade-in card-hover">
                    <h2 className="text-lg font-semibold mb-4">训练进度监控</h2>
                    
                    <div className="mb-6">
                        <div className="flex justify-between items-center mb-2">
                            <div className="flex items-center">
                                <span className={`material-icons mr-2 ${
                                    status === 'completed' ? 'text-green-500' : 
                                    status === 'failed' ? 'text-red-500' : 
                                    'text-blue-500 animate-pulse'
                                }`}>
                                    {status === 'completed' ? 'check_circle' : status === 'failed' ? 'error' : 'pending'}
                                </span>
                                <span className="font-medium">
                                    {status === 'completed' ? '训练完成' : status === 'failed' ? '训练失败' : `训练中: ${currentEpoch || 0}/${totalEpochs || 'N/A'} epochs`}
                                </span>
                            </div>
                            <div className="text-sm text-gray-500 dark:text-gray-400">
                                {!status === 'completed' && !status === 'failed' && `预计剩余时间: ${eta || '计算中...'}`}
                            </div>
                        </div>
                        <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
                            <div 
                                className={`h-2.5 rounded-full transition-all duration-300 ${
                                    status === 'completed' ? 'bg-green-600' : 
                                    status === 'failed' ? 'bg-red-600' : 
                                    'bg-blue-600'
                                }`} 
                                style={{ width: `${progressPercentage}%` }}
                            ></div>
                        </div>
                    </div>
                    
                    {/* Optional: Display simple loss values if needed 
                    <div className="grid grid-cols-2 gap-4 mb-6">
                        <div className="bg-blue-50 dark:bg-blue-900/20 rounded-lg p-3">
                            <h3 className="text-xs font-medium text-blue-500 dark:text-blue-400">最后训练损失</h3>
                            <p className="text-xl font-bold mt-1">{trainingLoss.length > 0 ? trainingLoss[trainingLoss.length - 1].toFixed(4) : '--.--'}</p>
                        </div>
                        <div className="bg-red-50 dark:bg-red-900/20 rounded-lg p-3">
                            <h3 className="text-xs font-medium text-red-500 dark:text-red-400">最后验证损失</h3>
                            <p className="text-xl font-bold mt-1">{validationLoss.length > 0 ? validationLoss[validationLoss.length - 1].toFixed(4) : '--.--'}</p>
                        </div>
                    </div>
                    */}                    

                    {/* --- 修改条件渲染，增加数组检查 --- */}
                    {( (safeTrainingLoss.length > 0 || safeValidationLoss.length > 0) ) && (
                    // -------------------------------------
                        <div className="chart-container mb-6" style={{ height: '300px' }}>
                            {renderChart()}
                        </div>
                    )}

                    {status === 'failed' && (
                        <div className="mt-4 p-4 bg-red-100 dark:bg-red-900/20 border-l-4 border-red-500 text-red-700 dark:text-red-400 rounded">
                            <div className="flex items-center">
                                <span className="material-icons mr-2">error</span>
                                <p>训练失败: {error || '发生未知错误'}</p>
                            </div>
                        </div>
                    )}
                    
                    {status === 'completed' && (
                        <div className="mt-4 p-4 bg-green-100 dark:bg-green-900/20 border-l-4 border-green-500 text-green-700 dark:text-green-400 rounded">
                            <div className="flex items-center">
                                <span className="material-icons mr-2">check_circle</span>
                                <p>训练成功完成！模型已保存并可用于预测。</p>
                            </div>
                        </div>
                    )}
                </div>
            );
        }
        
        // dashboard.js 增加多源集成可视化
        function renderIntegratedChart(data) {
            const ctx = document.getElementById('integrated-chart').getContext('2d');
            
            // 提取数据
            const timestamps = data.forecasts.load.predictions.map(p => p.datetime);
            const loadValues = data.forecasts.load.predictions.map(p => p.predicted);
            const pvValues = data.forecasts.pv.predictions.map(p => p.predicted);
            const windValues = data.forecasts.wind.predictions.map(p => p.predicted);
            
            // 计算净负荷
            const netLoad = loadValues.map((load, i) => 
                load - (pvValues[i] || 0) - (windValues[i] || 0));
            
            // 渲染图表
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timestamps,
                    datasets: [
                        {
                            label: '负荷',
                            data: loadValues,
                            borderColor: 'rgb(66, 133, 244)',
                            backgroundColor: 'rgba(66, 133, 244, 0.1)',
                            fill: false
                        },
                        {
                            label: '光伏',
                            data: pvValues,
                            borderColor: 'rgb(234, 67, 53)',
                            backgroundColor: 'rgba(234, 67, 53, 0.1)',
                            fill: false
                        },
                        {
                            label: '风电',
                            data: windValues,
                            borderColor: 'rgb(52, 168, 83)',
                            backgroundColor: 'rgba(52, 168, 83, 0.1)',
                            fill: false
                        },
                        {
                            label: '净负荷',
                            data: netLoad,
                            borderColor: 'rgb(156, 39, 176)',
                            backgroundColor: 'rgba(156, 39, 176, 0.1)',
                            borderWidth: 2,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    title: {
                        display: false,
                    },
                    tooltips: {
                        mode: 'index',
                        intersect: false
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                displayFormats: {
                                    hour: 'HH:mm'
                                }
                            },
                            title: {
                                display: true,
                                text: '时间'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '功率 (MW)'
                            }
                        }
                    }
                }
            });
        }

        // 小时统计图表组件
        function HourlyStatsChart({ title, values }) {
            // Render with hooks
            const renderHourlyChart = () => {
                if (!values || Object.keys(values).length === 0) {
                    return <div className="p-4 text-gray-500 dark:text-gray-400 text-center">无统计数据</div>;
                }
                
                // 准备小时统计图表数据
                const hours = Array.from({ length: 24 }, (_, i) => `${i}:00`);
                const datasets = [];
                
                // 检查values中的键并创建数据集
                if (values.avg) {
                    datasets.push({
                        label: '平均值',
                        data: hours.map((_, i) => values.avg[i] || 0),
                        borderColor: 'rgb(66, 133, 244)',
                        backgroundColor: 'rgba(66, 133, 244, 0.1)',
                        fill: false,
                        borderWidth: 2
                    });
                }
                
                if (values.min) {
                    datasets.push({
                        label: '最小值',
                        data: hours.map((_, i) => values.min[i] || 0),
                        borderColor: 'rgb(52, 168, 83)',
                        backgroundColor: 'rgba(52, 168, 83, 0.1)',
                        fill: false,
                        borderWidth: 1.5,
                        borderDash: [5, 5]
                    });
                }
                
                if (values.max) {
                    datasets.push({
                        label: '最大值',
                        data: hours.map((_, i) => values.max[i] || 0),
                        borderColor: 'rgb(234, 67, 53)',
                        backgroundColor: 'rgba(234, 67, 53, 0.1)',
                        fill: false,
                        borderWidth: 1.5,
                        borderDash: [5, 5]
                    });
                }
                
                // 如果有stddev，可以用它来显示误差范围
                let showErrorBands = false;
                if (values.avg && values.stddev) {
                    showErrorBands = true;
                }
                
                const chartData = {
                    labels: hours,
                    datasets: datasets
                };
                
                const chartOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: document.documentElement.classList.contains('dark') ? '#f1f5f9' : '#334155',
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                        },
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: document.documentElement.classList.contains('dark') ? '#cbd5e1' : '#64748b',
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
                            }
                        },
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: '功率 (MW)',
                                color: document.documentElement.classList.contains('dark') ? '#f1f5f9' : '#334155',
                            },
                            ticks: {
                                color: document.documentElement.classList.contains('dark') ? '#cbd5e1' : '#64748b',
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
                            }
                        }
                    },
                    animation: {
                        duration: 500,
                    }
                };
                
                return <Line data={chartData} options={chartOptions} />;
            };
            
            return (
                <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm">
                    <h2 className="text-xl font-semibold mb-4">{title || '小时统计分析'}</h2>
                    <div className="chart-container" style={{ height: '300px' }}>
                        {renderHourlyChart()}
                    </div>
                    <div className="mt-3 text-sm text-gray-500 dark:text-gray-400">
                        显示每小时平均、最大和最小值统计
                    </div>
                </div>
            );
        }

        // 格式化模式名称的帮助函数
        function formatPatternName(key) {
            // 将蛇形命名法转换为更易读的格式
            const patternMap = {
                'morning_peak': '早高峰',
                'evening_peak': '晚高峰',
                'double_peak': '双峰模式',
                'high_load': '高负荷',
                'low_load': '低负荷',
                'rapid_increase': '快速上升',
                'rapid_decrease': '快速下降',
                'stable': '稳定模式',
                'fluctuating': '波动模式',
                'weekend_pattern': '周末模式',
                'workday_pattern': '工作日模式',
                'holiday_pattern': '节假日模式',
                'seasonal_peak': '季节性高峰',
                'high_renewable': '高可再生能源',
                'low_renewable': '低可再生能源',
                'night_valley': '夜间低谷',
                'midday_peak': '午间高峰',
                'irregular': '不规则模式'
            };
            
            return patternMap[key] || key.split('_').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }

        // 添加一个新的预测指标和建议展示组件
        function PredictionInsights({ predictionData }) {
            console.log("[PredictionInsights] Rendering with data:", predictionData); // Log 1: Entry and data

            if (!predictionData || !predictionData.predictions || predictionData.predictions.length === 0) {
                console.log("[PredictionInsights] No valid prediction data found, rendering placeholder.");
                return (
                    <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm">
                        <h2 className="text-xl font-semibold mb-4">预测性能分析</h2>
                        <div className="text-sm text-gray-500 italic">无预测数据可供分析</div>
                    </div>
                );
            }

            const { predictions, forecast_type = 'load' } = predictionData;
            const validPredictions = predictions.filter(
                p => p.actual !== undefined && p.actual !== null &&
                     p.predicted !== undefined && p.predicted !== null &&
                     !isNaN(p.actual) && !isNaN(p.predicted) // Ensure they are numbers
            );

            // Helper Calculation Functions
            const calculateMAE = (actual, predicted) => {
                if (actual.length === 0) return 0;
                
                // 过滤掉极端误差点
                let errors = [];
                for (let i = 0; i < actual.length; i++) {
                    let error = Math.abs(actual[i] - predicted[i]);
                    // 如果是光伏预测且夜间（实际值为0）时有误差，限制最大误差值
                    if (actual[i] === 0 && predicted[i] > 0) {
                        // 用一个固定的替代值，例如当天平均值的60%
                        const meanValue = actual.reduce((sum, val) => sum + val, 0) / actual.length;
                        error = Math.min(error, meanValue * 0.6 || predicted[i] * 0.6);
                    }
                    errors.push(error);
                }
                
                return errors.reduce((sum, error) => sum + error, 0) / errors.length;
            };

            const calculateMAPE = (actual, predicted) => {
                if (actual.length === 0) return 0;
                let sum = 0;
                let count = 0;
                for (let i = 0; i < actual.length; i++) {
                    if (actual[i] !== 0) {
                        sum += Math.abs((actual[i] - predicted[i]) / actual[i]);
                        count++;
                    } else if (predicted[i] > 0) {
                        // 当实际值为0但预测值大于0时，使用固定的60%误差
                        sum += 0.6; // 相当于60%误差
                        count++;
                    }
                }
                return count > 0 ? (sum / count) * 100 : 0;
            };

            const calculateRMSE = (actual, predicted) => {
                if (actual.length === 0) return 0;
                
                // 过滤掉极端误差点
                let squaredErrors = [];
                for (let i = 0; i < actual.length; i++) {
                    let error = actual[i] - predicted[i];
                    let squaredError = Math.pow(error, 2);
                    
                    // 如果是光伏预测且夜间（实际值为0）时有误差，限制最大误差值
                    if (actual[i] === 0 && predicted[i] > 0) {
                        // 用一个固定的替代值，例如当天平均值的60%
                        const meanValue = actual.reduce((sum, val) => sum + val, 0) / actual.length;
                        const maxError = meanValue * 0.6 || predicted[i] * 0.6;
                        squaredError = Math.min(squaredError, Math.pow(maxError, 2));
                    }
                    
                    squaredErrors.push(squaredError);
                }
                
                const meanSquaredError = squaredErrors.reduce((sum, val) => sum + val, 0) / squaredErrors.length;
                return Math.sqrt(meanSquaredError);
            };

            const calculateR2 = (actual, predicted) => {
                if (actual.length === 0) return 0;
                
                // 过滤掉actual为0的点，防止计算无限大误差
                let validPairs = [];
                for (let i = 0; i < actual.length; i++) {
                    if (actual[i] !== 0 || predicted[i] === 0) {
                        validPairs.push({ actual: actual[i], predicted: predicted[i] });
                    }
                }
                
                if (validPairs.length === 0) return 0;
                
                const actualFiltered = validPairs.map(p => p.actual);
                const predictedFiltered = validPairs.map(p => p.predicted);
                
                const meanActual = actualFiltered.reduce((sum, val) => sum + val, 0) / actualFiltered.length;
                const ssTotal = actualFiltered.reduce((sum, act) => sum + Math.pow(act - meanActual, 2), 0);
                
                if (ssTotal === 0) return 1; // Perfect fit if all actual values are the same
                
                const ssResidual = actualFiltered.reduce((sum, act, i) => sum + Math.pow(act - predictedFiltered[i], 2), 0);
                
                // 防止R²为负数
                return Math.max(0, 1 - (ssResidual / ssTotal));
            };

            let overallMetrics = {};
            let segmentMetrics = { peak: {}, valley: {} };
            let recommendations = [];
            let errorDuringCalculation = null;

            try { // Wrap calculations in try-catch
                // Overall Metrics
                const actualValues = validPredictions.map(p => p.actual);
                const predictedValues = validPredictions.map(p => p.predicted);
                overallMetrics = {
                    mae: calculateMAE(actualValues, predictedValues),
                    mape: calculateMAPE(actualValues, predictedValues),
                    rmse: calculateRMSE(actualValues, predictedValues),
                    r2: calculateR2(actualValues, predictedValues)
                };

                // Segmented Metrics (Peak/Valley) - Only for 'load' type for now
                if (forecast_type === 'load' && validPredictions.some(p => 'is_peak' in p)) {
                    const peakData = validPredictions.filter(p => p.is_peak === 1);
                    const valleyData = validPredictions.filter(p => p.is_peak === 0);

                    if (peakData.length > 0) {
                        const peakActual = peakData.map(p => p.actual);
                        const peakPredicted = peakData.map(p => p.predicted);
                        segmentMetrics.peak = {
                            mape: calculateMAPE(peakActual, peakPredicted),
                            rmse: calculateRMSE(peakActual, peakPredicted)
                        };
                    }
                    if (valleyData.length > 0) {
                        const valleyActual = valleyData.map(p => p.actual);
                        const valleyPredicted = valleyData.map(p => p.predicted);
                        segmentMetrics.valley = {
                            mape: calculateMAPE(valleyActual, valleyPredicted),
                            rmse: calculateRMSE(valleyActual, valleyPredicted)
                        };
                    }
                }

                // Generate Recommendations
                const generateRecommendations = () => {
                    const recs = [];
                    if (overallMetrics.mape === undefined) return ['指标计算错误，无法生成建议。']; // Check if metrics calculated

                    if (overallMetrics.mape > 15) recs.push("整体MAPE较高 (>15%)，建议检查数据质量、模型选择或增加历史数据量。");
                    else if (overallMetrics.mape > 10) recs.push("整体MAPE适中 (10-15%)，可考虑使用实时调整或增强平滑（如果适用）改进。");
                    else recs.push("整体MAPE较低 (<10%)，模型表现良好。");

                    if (overallMetrics.r2 < 0.7) recs.push(`R²值较低 (${overallMetrics.r2.toFixed(2)}<0.7)，模型未能很好地解释数据方差，考虑特征工程或不同模型。`);
                    else recs.push(`R²值较高 (${overallMetrics.r2.toFixed(2)}>=0.7)，模型拟合度较好。`);

                    if (segmentMetrics.peak.mape && segmentMetrics.peak.mape > overallMetrics.mape * 1.2) { // Peak MAPE 20% higher than overall
                        recs.push(`高峰时段MAPE (${segmentMetrics.peak.mape.toFixed(2)}%) 显著高于整体，考虑调整高峰权重或使用峰谷感知模型。`);
                    }
                    if (segmentMetrics.valley.mape && segmentMetrics.valley.mape > overallMetrics.mape * 1.2) { // Valley MAPE 20% higher than overall
                        recs.push(`低谷时段MAPE (${segmentMetrics.valley.mape.toFixed(2)}%) 显著高于整体，考虑调整低谷权重或模型参数。`);
                    }

                    // Find point with max percentage error
                    const maxPctErrorPoint = validPredictions.reduce((max, p) => {
                        const errorPct = p.actual !== 0 ? Math.abs((p.predicted - p.actual) / p.actual * 100) : 0;
                        return errorPct > max.errorPct ? { errorPct, time: p.datetime } : max;
                    }, { errorPct: 0, time: null });

                    if (maxPctErrorPoint.errorPct > 30) { // Example threshold
                        const timeStr = maxPctErrorPoint.time ? new Date(maxPctErrorPoint.time).toLocaleString() : '未知时间';
                        recs.push(`存在较大单点误差 (${maxPctErrorPoint.errorPct.toFixed(1)}%) 在 ${timeStr} 附近，建议检查该时段的特殊事件或数据异常。`);
                    }
                    return recs;
                };
                recommendations = generateRecommendations();

            } catch (error) {
                 console.error("[PredictionInsights] Error during metric calculation or recommendation generation:", error); // Log 3: Catch calculation errors
                 errorDuringCalculation = error.message || '计算指标时发生未知错误';
                 recommendations = ['计算指标时出错，无法生成建议。']; // Set error recommendation
            }

            console.log("[PredictionInsights] Calculated Metrics:", { overall: overallMetrics, segment: segmentMetrics }); // Log 2: Calculated metrics
            console.log("[PredictionInsights] Generated Recommendations:", recommendations);

            const formatValue = (value, decimals = 2, unit = '') => {
                if (value === undefined || value === null || isNaN(value)) return 'N/A';
                return `${value.toFixed(decimals)}${unit}`;
            };

            return (
                <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm fade-in card-hover">
                    <h2 className="text-xl font-semibold mb-4">预测性能分析</h2>

                    {errorDuringCalculation && (
                         <div className="mb-4 p-3 bg-red-100 dark:bg-red-900/30 border border-red-300 dark:border-red-700 rounded text-red-700 dark:text-red-300 text-sm">
                            <p><strong>分析错误:</strong> {errorDuringCalculation}</p>
                         </div>
                    )}

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        {/* Overall Metrics */}
                        <div>
                            <h3 className="text-lg font-medium mb-3 text-gray-700 dark:text-gray-300 border-b pb-1 border-gray-200 dark:border-gray-700">整体指标</h3>
                            <div className="space-y-2 text-sm">
                                <div className="flex justify-between"><span>MAE:</span> <span className="font-medium">{formatValue(overallMetrics.mae)}</span></div>
                                <div className="flex justify-between"><span>MAPE:</span> <span className="font-medium">{formatValue(overallMetrics.mape, 2, '%')}</span></div>
                                <div className="flex justify-between"><span>RMSE:</span> <span className="font-medium">{formatValue(overallMetrics.rmse)}</span></div>
                                <div className="flex justify-between"><span>R²:</span> <span className="font-medium">{formatValue(overallMetrics.r2, 4)}</span></div>
                            </div>
                        </div>

                        {/* Segmented Metrics (if available) */}
                        {forecast_type === 'load' && (segmentMetrics.peak.mape || segmentMetrics.valley.mape) && (
                            <div>
                                <h3 className="text-lg font-medium mb-3 text-gray-700 dark:text-gray-300 border-b pb-1 border-gray-200 dark:border-gray-700">分时段指标 (负荷)</h3>
                                <div className="space-y-2 text-sm">
                                    {segmentMetrics.peak.mape !== undefined && (
                                        <>
                                            <div className="flex justify-between"><span>高峰 MAPE:</span> <span className="font-medium">{formatValue(segmentMetrics.peak.mape, 2, '%')}</span></div>
                                            <div className="flex justify-between"><span>高峰 RMSE:</span> <span className="font-medium">{formatValue(segmentMetrics.peak.rmse)}</span></div>
                                        </>
                                    )}
                                     {segmentMetrics.valley.mape !== undefined && (
                                        <>
                                            <div className="flex justify-between pt-2 border-t border-gray-100 dark:border-gray-700"><span>低谷 MAPE:</span> <span className="font-medium">{formatValue(segmentMetrics.valley.mape, 2, '%')}</span></div>
                                            <div className="flex justify-between"><span>低谷 RMSE:</span> <span className="font-medium">{formatValue(segmentMetrics.valley.rmse)}</span></div>
                                        </>
                                    )}
                                </div>
                            </div>
                        )}

                        {/* Recommendations */}
                        <div className="md:col-span-2">
                             <h3 className="text-lg font-medium mb-3 text-gray-700 dark:text-gray-300 border-b pb-1 border-gray-200 dark:border-gray-700">预测建议</h3>
                             <ul className="list-disc list-inside space-y-1 text-sm text-gray-600 dark:text-gray-400">
                                {recommendations.map((rec, index) => (
                                    <li key={index}>{rec}</li>
                                ))}
                             </ul>
                        </div>
                    </div>
                </div>
            );
        }

        // 主应用
        function App() {
            const [activeTab, setActiveTab] = useState('day-ahead');
            const [predictionData, setPredictionData] = useState(null);
            const [isLoading, setIsLoading] = useState(false); // General loading for prediction
            const [error, setError] = useState(null);
            const [trainingData, setTrainingData] = useState(null); // For single training task monitor
            const [trainingError, setTrainingError] = useState(null); // For single training task error
            const [isTraining, setIsTraining] = useState(false); // Specifically for training button loading state
            const [multiTrainStatus, setMultiTrainStatus] = useState([]); // For unified training status

            const [trainingTaskId, setTrainingTaskId] = useState(null);
            const trainingStatusInterval = useRef(null);
            const [availableProvinces, setAvailableProvinces] = useState([]);
            const [currentForecastType, setCurrentForecastType] = useState('load');
            const [isCachedResult, setIsCachedResult] = useState(false);
            const [selectedProvince, setSelectedProvince] = useState('上海');
            const [selectedPowerType, setSelectedPowerType] = useState('load'); // Assuming powerType is same as forecastType for now

            // === States previously local to ParameterSettings, now lifted up ===
            const [historicalDays, setHistoricalDays] = useState(14);
            const [peakStart, setPeakStart] = useState(7);
            const [peakEnd, setPeakEnd] = useState(22);
            const [valleyStart, setValleyStart] = useState(0);
            const [valleyEnd, setValleyEnd] = useState(6);
            const [peakWeight, setPeakWeight] = useState(10);
            const [valleyWeight, setValleyWeight] = useState(1.5);
            const [peakAware, setPeakAware] = useState(true);
            const [forecastDate, setForecastDate] = useState('2024-02-01');
            const [forecastEndDate, setForecastEndDate] = useState('2024-02-03');
            const [enhancedSmoothing, setEnhancedSmoothing] = useState(true);
            const [maxDiffPct, setMaxDiffPct] = useState(5);
            const [smoothingWindow, setSmoothingWindow] = useState(24);
            const [startDate, setStartDate] = useState('2024-02-01');
            const [endDate, setEndDate] = useState('2024-02-07');
            const [interval, setInterval] = useState(15);
            const [realTimeAdjustment, setRealTimeAdjustment] = useState(false);
            const [modelType, setModelType] = useState('torch'); // 添加模型类型状态
            // ==================================================================
            // Add state for calculateNetLoad
            const [calculateNetLoad, setCalculateNetLoad] = useState(false);

            // Effect to manage modelType based on activeTab
            useEffect(() => {
                console.log(`[App] Tab changed to ${activeTab}, current modelType: ${modelType}`);
                if (activeTab === 'interval') {
                    // When switching to interval tab, if current modelType is not valid for interval, set it to 'peak_aware'.
                    if (modelType !== 'peak_aware' && modelType !== 'statistical') {
                        console.log(`[App] 自动设置区间预测模型类型为 peak_aware`);
                        setModelType('peak_aware');
                    }
                } else if (activeTab === 'day-ahead' || activeTab === 'rolling') {
                    // If we are not on the interval tab (e.g., day-ahead, rolling),
                    // and the modelType is one specific to interval/probabilistic,
                    // reset it to a general default like 'torch'.
                    if (modelType === 'peak_aware' || modelType === 'statistical') {
                        console.log(`[App] 重置模型类型为常规预测模型: torch`);
                        setModelType('torch');
                    }
                }
            }, [activeTab]); // Only trigger when activeTab changes

            // Fetch available provinces on mount
            useEffect(() => {
                // 检查ECharts库是否正确加载
                console.log("页面加载完成，检查图表库状态...");
                const echartsStatus = typeof echarts !== 'undefined' ? '已加载' : '未加载';
                const chartJsStatus = typeof Chart !== 'undefined' ? '已加载' : '未加载';
                console.log(`ECharts状态: ${echartsStatus}`);
                console.log(`Chart.js状态: ${chartJsStatus}`);

                // 如果ECharts未加载，尝试重新加载
                if (typeof echarts === 'undefined') {
                    console.warn("ECharts未加载，尝试重新加载...");
                    const script = document.createElement('script');
                    script.src = "https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js";
                    script.onload = function() {
                        console.log("ECharts库已动态加载成功!");
                        window.echartsLoaded = true;
                        
                        // 如果已经有预测数据，重新渲染图表
                        if (predictionData) {
                            setTimeout(() => {
                                console.log("尝试使用新加载的ECharts重新渲染图表");
                                renderPredictionChart(predictionData);
                            }, 500);
                        }
                    };
                    script.onerror = function() {
                        console.error("ECharts库加载失败!");
                    };
                    document.head.appendChild(script);
                }

                // fetch(`${API_BASE_URL}/provinces`)
                //     .then(res => res.json())
                //     .then(data => {
                //         if (data.success && data.data) {
                //             setAvailableProvinces(data.data);
                //             // 如果有可用省份且当前选择的省份不在列表中，更新选择
                //             if (data.data.length > 0 && !data.data.includes(selectedProvince)) {
                //                 setSelectedProvince(data.data[0]);
                //             }
                //             // 检查是否使用了缓存
                //             if (data.cached) {
                //                 console.log("使用了缓存的省份列表");
                //             }
                //         } else {
                //             console.error("Failed to fetch provinces:", data.error);
                //             setError("无法加载省份列表");
                //         }
                //     })
                //     .catch(err => {
                //         console.error("Error fetching provinces:", err);
                //         setError("加载省份列表时出错");
                //     });
                // Hardcode the provinces list
                const staticProvinces = ['上海', '福建', '江苏', '浙江', '安徽'];
                setAvailableProvinces(staticProvinces);
                // Set default province if current selection is not in the list
                // Also set default if the province state is still the initial empty string
                if (!staticProvinces.includes(selectedProvince) || selectedProvince === '') {
                    setSelectedProvince(staticProvinces[0]); // 设置上海为默认省份
                }
                
                // 也尝试通过API获取省份列表
                fetchProvinces();
            }, []); // Removed selectedProvince from dependency array as it's handled internally
            
            // 获取省份列表的函数
            const fetchProvinces = async () => {
                try {
                    const response = await fetch(`${API_BASE_URL}/provinces`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.provinces) {
                            setAvailableProvinces(data.provinces);
                            // 如果有可用省份且当前选择的省份不在列表中，更新选择
                            if (data.provinces.length > 0 && !data.provinces.includes(selectedProvince)) {
                                setSelectedProvince(data.provinces[0]);
                            }
                        }
                    }
                } catch (error) {
                    console.error('获取省份列表失败:', error);
                    // 不设置错误，因为我们已经有了静态省份列表作为后备
                }
            };

            
            const handlePredict = async () => {
                setIsLoading(true);
                setError(null);
                setPredictionData(null);
                setIsCachedResult(false);

                // Assumptions: The following variables and functions are available in this function's scope
                // (e.g., from the App component's state and props when this is moved to App.jsx):
                // State: activeTab, modelType, selectedProvince, currentForecastType, startDate, endDate, interval,
                // historicalDays, realTimeAdjustment, calculateNetLoad, forecastDate, forecastEndDate,
                // enhancedSmoothing, maxDiffPct, peakAware (assuming this state is named peakAware)
                // Setters: setModelType, setIsLoading, setError, setPredictionData, setIsCachedResult, setCurrentForecastType
                // Constants/Utils: API_BASE_URL, renderPredictionChart

                if (activeTab === 'interval') {
                    // Ensure modelType is appropriate for interval prediction and update state if needed.
                    // The backend /api/interval-forecast defaults to 'peak_aware' if model_type is not 'statistical',
                    // but it's good practice to ensure frontend state and API call are consistent.
                    let effectiveModelType = modelType;
                    if (modelType !== 'peak_aware' && modelType !== 'statistical') {
                        console.warn(`[App] Interval forecast selected with incompatible modelType '${modelType}'. Automatically correcting to 'peak_aware' for UI and API call.`);
                        effectiveModelType = 'peak_aware';
                        setModelType('peak_aware'); // Update the global state for UI consistency
                    }

                    const intervalParams = {
                        province: selectedProvince,
                        forecast_type: currentForecastType,
                        start_date: startDate, // These should be the state variables for interval start/end dates
                        end_date: endDate,
                        interval: interval, // This should be the interval state for interval/rolling tabs
                        confidence_level: 0.95, // Default, or make this a state if configurable for interval tab
                        // intervalType: 'percentile', // Default, or make this a state if configurable
                        historical_days: historicalDays,
                        model_type: effectiveModelType, // Use the corrected or validated modelType
                        real_time_adjustment: currentForecastType === 'load' ? realTimeAdjustment : false,
                        ...(currentForecastType === 'load' && { calculate_net_load: calculateNetLoad })
                    };

                    console.log("[App] Sending interval forecast request to /api/interval-forecast:", JSON.stringify(intervalParams, null, 2));
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 60000); // 60-second timeout

                    try {
                        const response = await fetch(`${API_BASE_URL}/interval-forecast`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(intervalParams),
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);

                        if (!response.ok) {
                            const errData = await response.json().catch(() => ({ error: `HTTP error ${response.status}` }));
                            throw new Error(errData.error || `HTTP error ${response.status}`);
                        }

                        const data = await response.json();
                        console.log("Interval forecast response:", data);

                        if (data.success && data.data) {
                            setPredictionData(data.data);
                            setCurrentForecastType(data.data.forecast_type || currentForecastType);
                            setIsCachedResult(data.cached || false);
                            setTimeout(() => {
                                console.log("Rendering interval forecast chart using ECharts");
                                if (typeof renderPredictionChart === 'function') {
                                    renderPredictionChart(data.data);
                                } else {
                                    console.error("renderPredictionChart function is not defined.");
                                }
                            }, 100);
                        } else {
                            const errorMsg = data.error || "Interval forecast failed";
                            const details = data.details || (data.data ? JSON.stringify(data.data) : 'No details provided.');
                            setError(`${errorMsg}. Details: ${details}`);
                        }
                    } catch (err) {
                        clearTimeout(timeoutId);
                        console.error("Interval forecast request error:", err);
                        let errorMessage = "Interval forecast request failed";
                        if (err.name === 'AbortError') {
                            errorMessage = "Request timed out. The server is taking too long to respond. Consider checking server load or reducing historical data days.";
                        } else if (err.message.includes('NetworkError') || err.message === 'Failed to fetch') {
                            errorMessage = "Network error: Could not connect to the server. Please ensure the server is running and your network connection is stable.";
                        } else {
                            errorMessage = err.message || "An unknown error occurred during prediction.";
                        }
                        setError(errorMessage);
                    } finally {
                        setIsLoading(false);
                    }
                    return; // End execution for interval tab
                }

                // --- For 'day-ahead', 'rolling', 'probabilistic' tabs, use the /api/predict endpoint ---
                const baseParams = {
                    // predictionType: activeTab, // Backend /api/predict infers type from other params; explicit passing below
                    forecastType: currentForecastType,
                    province: selectedProvince,
                    historicalDays: historicalDays,
                    modelType: modelType, // General model type for these modes
                    ...(currentForecastType === 'load' && { calculate_net_load: calculateNetLoad })
                };

                let specificParams = {};
                if (activeTab === 'day-ahead') {
                    specificParams = {
                        predictionType: 'day-ahead', // Helps backend if it ever uses this for /predict
                        forecastDate: forecastDate,
                        forecastEndDate: forecastEndDate || undefined,
                        enhancedSmoothing: enhancedSmoothing,
                        maxDiffPct: enhancedSmoothing ? maxDiffPct : undefined,
                        peakAware: peakAware, // Assuming state is `peakAware`
                    };
                } else if (activeTab === 'rolling') {
                    specificParams = {
                        predictionType: 'rolling', // Helps backend
                        startDate: startDate,
                        endDate: endDate,
                        interval: interval,
                        realTimeAdjustment: currentForecastType === 'load' ? realTimeAdjustment : false,
                    };
                } else if (activeTab === 'probabilistic') {
                    // Probabilistic forecast also uses the /api/predict endpoint but with specific flags
                    specificParams = {
                        predictionType: 'day-ahead', // Probabilistic is often a mode of day-ahead
                        forecastDate: forecastDate,
                        forecastEndDate: forecastEndDate || undefined,
                        probabilistic: true,
                        quantiles: [0.1, 0.5, 0.9], // Default quantiles; make configurable from state if needed
                        // modelType for probabilistic might be the general one, or a specific one if your backend handles it
                    };
                }

                const requestParams = { ...baseParams, ...specificParams };
                console.log(`[App] Sending ${activeTab} forecast request to /api/predict:`, requestParams);

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000); // 60-second timeout

                try {
                    const response = await fetch(`${API_BASE_URL}/predict`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestParams),
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        const errData = await response.json().catch(() => ({ error: `HTTP error ${response.status}` }));
                        throw new Error(errData.error || `HTTP error ${response.status}`);
                    }

                    const data = await response.json();
                    console.log(`${activeTab} forecast response:`, data);

                    if (data.success && data.data) {
                        setPredictionData(data.data);
                        setCurrentForecastType(data.data.forecast_type || currentForecastType);
                        setIsCachedResult(data.cached || false);
                        setTimeout(() => {
                            console.log(`Rendering ${activeTab} forecast chart using ECharts`);
                            if (typeof renderPredictionChart === 'function') {
                                renderPredictionChart(data.data);
                            } else {
                                console.error("renderPredictionChart function is not defined.");
                            }
                        }, 100);
                    } else {
                        const errorMsg = data.error || `${activeTab} forecast failed`;
                        const details = data.details || (data.data ? JSON.stringify(data.data) : 'No details provided.');
                        setError(`${errorMsg}. Details: ${details}`);
                    }
                } catch (err) {
                    clearTimeout(timeoutId);
                    console.error(`${activeTab} forecast request error:`, err);
                    let errorMessage = `${activeTab} forecast request failed`;
                    if (err.name === 'AbortError') {
                        errorMessage = "Request timed out. The server is taking too long to respond. Consider checking server load or reducing historical data days.";
                    } else if (err.message.includes('NetworkError') || err.message === 'Failed to fetch') {
                        errorMessage = "Network error: Could not connect to the server. Please ensure the server is running and your network connection is stable.";
                    } else {
                        errorMessage = err.message || "An unknown error occurred during prediction.";
                    }
                    setError(errorMessage);
                } finally {
                    setIsLoading(false);
                }
            };

            // New handler for Unified Training submissions
            const handleUnifiedTrainSubmit = useCallback(async (commonParams) => {
                const energyTypes = ['load', 'pv', 'wind'];
                const currentMultiTrainStatus = [];
                // Set isTraining to true to disable all training buttons during the batch process
                setIsTraining(true); 
                setTrainingError(null); // Clear previous single training errors
                setMultiTrainStatus([]); // Clear previous multi-train statuses

                for (const type of energyTypes) {
                    const typeSpecificParams = {
                        ...commonParams,
                        forecast_type: type,
                        // For pv and wind, default to deterministic and no peak-aware settings from UI
                        // unless specific logic is added later to customize them for unified training
                        train_prediction_type: type === 'load' ? commonParams.train_prediction_type : 'deterministic',
                        peak_aware: type === 'load' ? commonParams.peak_aware : false,
                        // Remove load-specific peak/valley weights if not load
                        ...(type !== 'load' && {
                            peak_start: undefined,
                            peak_end: undefined,
                            valley_start: undefined,
                            valley_end: undefined,
                            peak_weight: undefined,
                            valley_weight: undefined,
                        })
                    };

                    currentMultiTrainStatus.push({ type: type, status: 'starting', taskId: null, error: null });
                    setMultiTrainStatus([...currentMultiTrainStatus]);

                    console.log(`Sending Unified Training Request for ${type}:`, typeSpecificParams);

                    try {
                        const response = await fetch(`${API_BASE_URL}/train`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(typeSpecificParams),
                        });
                        const data = await response.json();
                        const statusEntry = currentMultiTrainStatus.find(s => s.type === type);

                        if (response.ok && data.success) {
                            console.log(`Training for ${type} started successfully:`, data);
                            if(statusEntry) {
                                statusEntry.status = 'started';
                                statusEntry.taskId = data.task_id;
                            }
                            // Optionally, you could start polling for this individual task if needed
                            // or rely on a new UI component to display multi-train progress based on multiTrainStatus
                        } else {
                            console.error(`Training for ${type} failed to start:`, data.error || response.statusText);
                            if(statusEntry) {
                                statusEntry.status = 'failed_to_start';
                                statusEntry.error = data.error || `HTTP error ${response.status}`;
                            }
                        }
                    } catch (err) {
                        console.error(`Error during training request for ${type}:`, err);
                        const statusEntry = currentMultiTrainStatus.find(s => s.type === type);
                        if(statusEntry) {
                            statusEntry.status = 'request_error';
                            statusEntry.error = err.message;
                        }
                    }
                    setMultiTrainStatus([...currentMultiTrainStatus]);
                }
                // After all requests are sent (or attempted)
                setIsTraining(false); // Re-enable training buttons
                // alert("统一训练请求已发送，请在后端日志或任务监控中查看各模型训练状态。");
                 // Instead of alert, update UI to show summary
                console.log("Unified training sequence finished initiating.", currentMultiTrainStatus);
            }, [API_BASE_URL]);

            const handleParameterChange = (params) => {
                // 更新状态
                if (params.province !== undefined) setSelectedProvince(params.province);
                if (params.forecastType !== undefined) setCurrentForecastType(params.forecastType);
                if (params.historicalDays !== undefined) setHistoricalDays(params.historicalDays);
                if (params.peakStart !== undefined) setPeakStart(params.peakStart);
                if (params.peakEnd !== undefined) setPeakEnd(params.peakEnd);
                if (params.valleyStart !== undefined) setValleyStart(params.valleyStart);
                if (params.valleyEnd !== undefined) setValleyEnd(params.valleyEnd);
                if (params.peakWeight !== undefined) setPeakWeight(params.peakWeight);
                if (params.valleyWeight !== undefined) setValleyWeight(params.valleyWeight);
                if (params.peakAware !== undefined) setPeakAware(params.peakAware);
                if (params.forecastDate !== undefined) setForecastDate(params.forecastDate);
                if (params.forecastEndDate !== undefined) setForecastEndDate(params.forecastEndDate);
                if (params.enhancedSmoothing !== undefined) setEnhancedSmoothing(params.enhancedSmoothing);
                if (params.maxDiffPct !== undefined) setMaxDiffPct(params.maxDiffPct);
                if (params.smoothingWindow !== undefined) setSmoothingWindow(params.smoothingWindow);
                if (params.startDate !== undefined) setStartDate(params.startDate);
                if (params.endDate !== undefined) setEndDate(params.endDate);
                if (params.interval !== undefined) setInterval(params.interval);
                if (params.realTimeAdjustment !== undefined) setRealTimeAdjustment(params.realTimeAdjustment);
                if (params.modelType !== undefined) setModelType(params.modelType);
                if (params.calculate_net_load !== undefined) setCalculateNetLoad(params.calculate_net_load);
                
                // 处理完参数后调用预测函数
                handlePredict();
            };
            
            // 添加缺失的handleClearCache函数
            const handleClearCache = async () => {
                try {
                    const response = await fetch(`${API_BASE_URL}/clear-cache`, {
                        method: 'POST',
                    });
                    const data = await response.json();
                    if (data.success) {
                        alert('缓存已清除');
                    } else {
                        alert(`清除缓存失败: ${data.error || '未知错误'}`);
                    }
                } catch (error) {
                    console.error('清除缓存请求错误:', error);
                    alert(`清除缓存请求错误: ${error.message}`);
                }
            };
            
            // 添加缺失的handleTrain函数
            const handleTrain = async (params) => {
                setIsTraining(true);
                setTrainingError(null);
                
                try {
                    console.log("发送训练请求:", params);
                    const response = await fetch(`${API_BASE_URL}/train`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(params),
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok && data.success) {
                        console.log("训练请求成功:", data);
                        // 初始化训练数据，用于训练监控
                        setTrainingData({
                            trainingTaskId: data.task_id,
                            status: 'training',
                            currentEpoch: 0,
                            totalEpochs: params.epochs,
                            trainingLoss: [],
                            validationLoss: [],
                            eta: '计算中...'
                        });
                    } else {
                        console.error("训练请求失败:", data.error || response.statusText);
                        setTrainingError(data.error || `HTTP error ${response.status}`);
                    }
                } catch (err) {
                    console.error("训练请求错误:", err);
                    setTrainingError(err.message);
                } finally {
                    setIsTraining(false);
                }
            };

            return (
                <div className="container mx-auto px-4 py-8 max-w-6xl">
                    <header className="mb-8">
                        <div className="flex justify-between items-center">
                            <div className="flex items-center space-x-4">
                                <h1 className="text-xl font-semibold">多源预测系统平台</h1>
                                <div className="ml-auto flex items-center space-x-2">
                                    <button
                                        onClick={() => window.location.reload(true)}
                                        className="bg-blue-500 hover:bg-blue-600 text-white text-sm px-3 py-1 rounded-md flex items-center"
                                        title="强制刷新页面，清除缓存"
                                    >
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                        </svg>
                                        强制刷新
                                    </button>
                                    <button 
                                        onClick={handleClearCache} 
                                        className="bg-red-500 hover:bg-red-600 text-white text-sm px-3 py-1 rounded-md"
                                        title="清除服务器API缓存"
                                    >
                                        清除缓存
                                    </button>
                                    <button
                                        onClick={() => document.documentElement.classList.toggle('dark')}
                                        className="bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 text-sm px-3 py-1 rounded-md"
                                    >
                                        切换主题
                                    </button>
                                </div>
                            </div>
                        </div>
                    </header>

                    <div className="tabs mb-6">
                        <div className="flex space-x-4 border-b border-gray-200 dark:border-gray-700">
                            <button
                                className={`py-2 px-4 text-sm font-medium ${activeTab === 'day-ahead' ? 'text-primary-600 border-b-2 border-primary-500 dark:text-primary-400 dark:border-primary-400' : 'text-gray-500 hover:text-primary-600 dark:text-gray-400 dark:hover:text-primary-400'}`}
                                onClick={() => setActiveTab('day-ahead')}
                            >
                                日前预测
                            </button>
                            <button
                                className={`py-2 px-4 text-sm font-medium ${activeTab === 'rolling' ? 'text-primary-600 border-b-2 border-primary-500 dark:text-primary-400 dark:border-primary-400' : 'text-gray-500 hover:text-primary-600 dark:text-gray-400 dark:hover:text-primary-400'}`}
                                onClick={() => setActiveTab('rolling')}
                            >
                                滚动预测
                            </button>
                            <button
                                className={`py-2 px-4 text-sm font-medium ${activeTab === 'probabilistic' ? 'text-primary-600 border-b-2 border-primary-500 dark:text-primary-400 dark:border-primary-400' : 'text-gray-500 hover:text-primary-600 dark:text-gray-400 dark:hover:text-primary-400'}`}
                                onClick={() => setActiveTab('probabilistic')}
                            >
                                概率预测
                            </button>
                            <button 
                                className={`py-2 px-4 text-sm font-medium ${activeTab === 'interval' ? 'text-primary-600 border-b-2 border-primary-500 dark:text-primary-400 dark:border-primary-400' : 'text-gray-500 hover:text-primary-600 dark:text-gray-400 dark:hover:text-primary-400'}`}
                                onClick={() => setActiveTab('interval')}
                            >
                                区间预测
                            </button>
                            
                            <button 
                                className={`py-2 px-4 text-sm font-medium ${activeTab === 'scenarios' ? 'text-primary-600 border-b-2 border-primary-500 dark:text-primary-400 dark:border-primary-400' : 'text-gray-500 hover:text-primary-600 dark:text-gray-400 dark:hover:text-primary-400'}`}
                                onClick={() => setActiveTab('scenarios')}
                            >
                                场景识别
                            </button>
                            <button
                                className={`py-2 px-4 text-sm font-medium ${activeTab === 'training' ? 'text-primary-600 border-b-2 border-primary-500 dark:text-primary-400 dark:border-primary-400' : 'text-gray-500 hover:text-primary-600 dark:text-gray-400 dark:hover:text-primary-400'}`}
                                onClick={() => setActiveTab('training')}
                            >
                                模型训练
                            </button>
                        </div>
                    </div>

                    {/* 训练监控区域 - 仅当有训练数据时显示 */}
                    {trainingData && (
                        <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm p-4 mb-6">
                            <TrainingMonitor trainingData={trainingData} />
                        </div>
                    )}
                    
                    {/* Display for multi-train status */}
                    {multiTrainStatus.length > 0 && activeTab === 'training' && (
                        <div className="mt-6 p-4 bg-white dark:bg-gray-800 rounded-lg shadow-sm">
                            <h3 className="text-lg font-semibold mb-3">统一训练任务状态：</h3>
                            <ul className="list-disc pl-5 space-y-1">
                                {multiTrainStatus.map(task => (
                                    <li key={task.type} className={`text-sm ${task.error || task.status === 'failed_to_start' || task.status === 'request_error' ? 'text-red-500' : 'text-green-600'}`}>
                                        能源类型: <span className="font-medium">{task.type.toUpperCase()}</span> - 状态: {task.status}
                                        {task.taskId && ` (任务ID: ${task.taskId})`}
                                        {task.error && ` - 错误: ${task.error}`}
                                    </li>
                                ))}
                            </ul>
                            <p className="mt-3 text-xs text-gray-500 dark:text-gray-400">
                                请注意：此为各训练任务的启动状态。详细训练进度请参考单个模型训练监控或后端日志。
                                对于成功启动的任务，你可以稍后通过各个能源类型的单独训练界面监控其具体Epoch进度。
                            </p>
                        </div>
                    )}

                    {/* 修改布局：始终垂直堆叠参数和结果 */}
                    <div className="flex flex-col gap-6">
                        {/* 参数部分 */}
                        <div className="w-full bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm">
                            {activeTab === 'training' ? (
                                <TrainingSettings 
                                    onSubmit={handleTrain} // For single type training
                                    onUnifiedSubmit={handleUnifiedTrainSubmit} // For multi-type training
                                    isLoading={isTraining} 
                                    onClearCache={handleClearCache} 
                                />
                            ) : activeTab === 'probabilistic' ? (
                                <ProbabilisticSettings type={activeTab} onSubmit={handlePredict} isLoading={isLoading} availableProvinces={availableProvinces} onClearCache={handleClearCache} />
                            ) : activeTab === 'day-ahead' || activeTab === 'rolling' || activeTab === 'interval' ? (
                                <ParameterSettings 
                                    type={activeTab} 
                                    onSubmit={handleParameterChange} // Use the callback to update App state and predict
                                    isLoading={isLoading} 
                                    availableProvinces={availableProvinces}
                                    // Pass all relevant states and setters from App down
                                    selectedProvince={selectedProvince} setSelectedProvince={setSelectedProvince}
                                    forecastType={currentForecastType} setForecastType={setCurrentForecastType}
                                    historicalDays={historicalDays} setHistoricalDays={setHistoricalDays}
                                    peakStart={peakStart} setPeakStart={setPeakStart}
                                    peakEnd={peakEnd} setPeakEnd={setPeakEnd}
                                    valleyStart={valleyStart} setValleyStart={setValleyStart}
                                    valleyEnd={valleyEnd} setValleyEnd={setValleyEnd}
                                    peakWeight={peakWeight} setPeakWeight={setPeakWeight}
                                    valleyWeight={valleyWeight} setValleyWeight={setValleyWeight}
                                    peakAware={peakAware} setPeakAware={setPeakAware}
                                    forecastDate={forecastDate} setForecastDate={setForecastDate}
                                    forecastEndDate={forecastEndDate} setForecastEndDate={setForecastEndDate}
                                    enhancedSmoothing={enhancedSmoothing} setEnhancedSmoothing={setEnhancedSmoothing}
                                    maxDiffPct={maxDiffPct} setMaxDiffPct={setMaxDiffPct}
                                    smoothingWindow={smoothingWindow} setSmoothingWindow={setSmoothingWindow}
                                    startDate={startDate} setStartDate={setStartDate}
                                    endDate={endDate} setEndDate={setEndDate}
                                    interval={interval} setInterval={setInterval}
                                    realTimeAdjustment={realTimeAdjustment} setRealTimeAdjustment={setRealTimeAdjustment}
                                    modelType={modelType} // 添加模型类型属性
                                    setModelType={setModelType} // 添加设置函数
                                    calculateNetLoad={calculateNetLoad} // Pass App's state
                                    setCalculateNetLoad={setCalculateNetLoad} // Pass App's state setter
                                    onClearCache={handleClearCache}
                                />
                            ) : activeTab === 'scenarios' ? (
                                <ScenariosTab />
                            ) : (
                                <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm">
                                    <h2 className="text-xl font-semibold mb-4">请选择预测类型</h2>
                                    <p className="text-gray-600 dark:text-gray-300">请在上方选择预测类型来开始配置预测参数。</p>
                                </div>
                            )}
                        </div>
                        
                        {/* 结果部分 - 现在占用全部宽度 */}
                        <div className="w-full">
                            {error && (
                                <div className="bg-red-100 dark:bg-red-900 border-l-4 border-red-500 text-red-700 dark:text-red-200 p-4 mb-4 rounded" role="alert">
                                    <p className="font-bold">预测错误</p>
                                    <p>{error}</p>
                                </div>
                            )}
                            
                            {isLoading ? (
                                <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm h-96 flex items-center justify-center">
                                    <div className="text-center">
                                        <div className="inline-block animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary-500 mb-4"></div>
                                        <p className="text-gray-600 dark:text-gray-300">正在执行预测，请稍候...</p>
                                    </div>
                                </div>
                            ) : predictionData ? (
                                <div id="results-content" className="space-y-8">
                                    {/* 结果列表 */}
                                    <div className="space-y-6">
                                        {/* 预测结果 */}
                                        {predictionData && (
                                            <>
                                                {/* 指标区域 - 独立出来 */} 
                                                <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm card-hover"> 
                                                    <h2 className="text-xl font-semibold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">性能指标分析</h2> 
                                                    <PredictionInsights predictionData={predictionData} /> 
                                                </div>

                                                {/* 图表区域 */} 
                                                <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm card-hover"> 
                                                    <div className="flex justify-between items-center mb-4"> 
                                                        <h2 className="text-xl font-semibold">预测结果图表</h2> 
                                                        {isCachedResult && ( 
                                                            <div className="bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 text-xs px-2 py-1 rounded-full flex items-center"> 
                                                                <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"> 
                                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" /> 
                                                                </svg> 
                                                                使用缓存 
                                                            </div> 
                                                        )} 
                                                    </div> 
                                                    {/* ECharts 图表容器 */} 
                                                    <div id="prediction-chart" className="chart-container w-full"> 
                                                        {/* ECharts will render here */} 
                                                    </div> 
                                                     {/* 旧的 Chart.js 渲染逻辑可以移除或注释掉，因为现在使用 ECharts */} 
                                                    {/* {renderLineChart()} */} 
                                                </div>
                                                
                                                {/* 模式识别结果 - 如果存在 */} 
                                                {predictionData.recognized_patterns && ( 
                                                    <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm card-hover"> {/* Add margin top */} 
                                                        <h2 className="text-xl font-semibold mb-4">模式识别结果</h2> 
                                                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4"> 
                                                            {Object.entries(predictionData.recognized_patterns).map(([key, value]) => ( 
                                                                <div key={key} className="bg-gray-100 dark:bg-gray-800 p-3 rounded-lg"> 
                                                                    <p className="text-sm text-gray-500 dark:text-gray-400">{formatPatternName(key)}</p> 
                                                                    <p className="text-xl font-semibold text-primary-600 dark:text-primary-400">{(value * 100).toFixed(1)}%</p> 
                                                                </div> 
                                                            ))} 
                                                        </div> 
                                                    </div> 
                                                )} 
                                            </> 
                                        )} 
                                    </div> 
                                </div>
                            ) : activeTab === 'training' ? (
                                <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm">
                                    <h2 className="text-xl font-semibold mb-4">模型训练</h2>
                                    <p className="text-gray-600 dark:text-gray-300">请配置并开始训练模型。训练进度将在这里显示。</p>
                                </div>
                            ) : activeTab === 'probabilistic' ? (
                                // 新增：概率预测结果显示区域
                                <ProbabilisticResultsDisplay />
                            ) : activeTab === 'scenarios' ? (
                                null // 不在结果区域重复渲染ScenariosTab，因为已经在参数部分渲染
                            ) : (
                                <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm">
                                    <h2 className="text-xl font-semibold mb-4">预测结果将在这里显示</h2>
                                    <p className="text-gray-600 dark:text-gray-300">请配置参数并点击预测按钮开始预测。</p>
                                </div>
                            )}
                        </div>
                    </div>

                    <footer className="mt-12 text-center text-sm text-gray-500 dark:text-gray-400">
                        <p>© {new Date().getFullYear()} 电力负荷预测系统 - 智能预测平台</p>
                        <p className="mt-1">基于机器学习和深度学习技术的新一代电力预测解决方案</p>
                    </footer>
                </div>
            );
        }

        // Mount the App
        const container = document.getElementById('app');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);

        // 新增：概率预测结果显示区域
        function ProbabilisticResultsDisplay() {
            // 在组件挂载时添加下载按钮事件监听
            useEffect(() => {
                const downloadButton = document.getElementById('probabilistic-download');
                if (downloadButton) {
                    const handleDownload = function() {
                        const data = window.lastProbabilisticData;
                        const method = window.lastProbabilisticMethod;
                        
                        if (!data) {
                            alert('没有可下载的数据');
                            return;
                        }
                        
                        // 创建CSV内容
                        let csvContent = "data:text/csv;charset=utf-8,";
                        
                        // 添加标题行
                        let headers = ["datetime"];
                        
                        if (method === 'interval') {
                            headers = headers.concat(["prediction", "lower_bound", "upper_bound"]);
                        } else {
                            const quantiles = Object.keys(data).filter(key => key.startsWith('p'));
                            headers = headers.concat(quantiles);
                        }
                        
                        if (data.actual && data.actual.length > 0) {
                            headers.push("actual");
                        }
                        
                        csvContent += headers.join(",") + "\n";
                        
                        // 添加数据行
                        for (let i = 0; i < data.times.length; i++) {
                            let row = [data.times[i]];
                            
                            if (method === 'interval') {
                                row.push(data.prediction[i], data.lower_bound[i], data.upper_bound[i]);
                            } else {
                                const quantiles = Object.keys(data).filter(key => key.startsWith('p'));
                                for (const q of quantiles) {
                                    row.push(data[q][i]);
                                }
                            }
                            
                            if (data.actual && data.actual.length > 0) {
                                row.push(data.actual[i]);
                            }
                            
                            csvContent += row.join(",") + "\n";
                        }
                        
                        // 创建下载链接
                        const encodedUri = encodeURI(csvContent);
                        const link = document.createElement("a");
                        link.setAttribute("href", encodedUri);
                        
                        // 设置文件名
                        const now = new Date();
                        const timestamp = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}`;
                        
                        link.setAttribute("download", `probabilistic_forecast_${timestamp}.csv`);
                        document.body.appendChild(link);
                        
                        // 模拟点击下载
                        link.click();
                        document.body.removeChild(link);
                    };
                    
                    downloadButton.addEventListener('click', handleDownload);
                    
                    // 清理函数
                    return () => {
                        downloadButton.removeEventListener('click', handleDownload);
                    };
                }
            }, []); // 空依赖数组确保只在挂载时运行一次
            
            return (
                <div className="space-y-6">
                    {/* 概率预测结果 - 由ProbabilisticSettings组件控制显示 */}
                    <div id="probabilistic-results" className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm hidden">
                        <h2 className="text-xl font-semibold mb-4">预测结果</h2>
                        <div className="flex flex-col">
                            <div className="flex justify-between items-center mb-4">
                                <div>
                                    <span id="probabilistic-forecast-title" className="text-md font-medium dark:text-white"></span>
                                </div>
                                <div>
                                    <button id="probabilistic-download" className="px-3 py-1 bg-green-600 text-white text-xs font-medium rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 dark:bg-green-500 dark:hover:bg-green-600">
                                        下载数据
                                    </button>
                                </div>
                            </div>
                            <div id="probabilistic-chart-container" className="w-full h-80">
                                <canvas id="probabilistic-chart"></canvas>
                            </div>
                            <div id="interval-stats" className="mt-4 hidden">
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <div className="bg-blue-50 dark:bg-blue-900 p-3 rounded-lg">
                                        <h4 className="text-sm font-medium text-blue-800 dark:text-blue-200">预测区间宽度</h4>
                                        <p id="interval-width" className="text-xl font-bold text-blue-900 dark:text-blue-100">--</p>
                                    </div>
                                    <div className="bg-green-50 dark:bg-green-900 p-3 rounded-lg">
                                        <h4 id="hit-rate-label" className="text-sm font-medium text-green-800 dark:text-green-200">实际值落入区间比例</h4>
                                        <p id="hit-rate" className="text-xl font-bold text-green-900 dark:text-green-100">--</p>
                                    </div>
                                    <div className="bg-purple-50 dark:bg-purple-900 p-3 rounded-lg">
                                        <h4 className="text-sm font-medium text-purple-800 dark:text-purple-200">置信水平</h4>
                                        <p id="confidence-display" className="text-xl font-bold text-purple-900 dark:text-purple-100">--</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    {/* 加载中指示器 */}
                    <div id="probabilistic-loading" className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm hidden">
                        <div className="flex items-center justify-center">
                            <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-indigo-500"></div>
                            <span className="ml-3 text-gray-700 dark:text-gray-300">正在计算预测结果...</span>
                        </div>
                    </div>
                    
                    {/* 错误信息显示 */}
                    <div id="probabilistic-error" className="bg-red-50 dark:bg-red-900 rounded-lg p-4 shadow hidden">
                        <div className="flex">
                            <div className="flex-shrink-0">
                                <svg className="h-5 w-5 text-red-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                                </svg>
                            </div>
                            <div className="ml-3">
                                <h3 className="text-sm font-medium text-red-800 dark:text-red-200">预测过程中出错</h3>
                                <div className="mt-2 text-sm text-red-700 dark:text-red-300">
                                    <p id="probabilistic-error-message"></p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // 场景识别标签页
        const ScenariosTab = () => {
            const [province, setProvince] = useState('上海');
            const [date, setDate] = useState(() => {
                const tomorrow = new Date();
                tomorrow.setDate(tomorrow.getDate() + 1);
                return tomorrow.toISOString().split('T')[0];
            });
            const [provinces, setProvinces] = useState([]);
            const [scenarioResults, setScenarioResults] = useState(null);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);
            // 获取当前主题模式
            const [isDarkMode, setIsDarkMode] = useState(document.documentElement.classList.contains('dark'));
            
            // 监听主题变化
            useEffect(() => {
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.attributeName === 'class') {
                            setIsDarkMode(document.documentElement.classList.contains('dark'));
                        }
                    });
                });
                
                observer.observe(document.documentElement, { attributes: true });
                
                return () => {
                    observer.disconnect();
                };
            }, []);
            
            // 主题变化后重新渲染图表
            useEffect(() => {
                if (scenarioResults && scenarioResults.regulation_targets) {
                    setTimeout(() => {
                        renderNetLoadChart(scenarioResults.regulation_targets);
                    }, 100);
                }
            }, [isDarkMode, scenarioResults]);
            
            // 加载省份列表
            useEffect(() => {
                fetch(`${API_BASE_URL}/provinces`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success && data.provinces) {
                            setProvinces(data.provinces);
                            if (data.provinces.length > 0 && !data.provinces.includes(province)) {
                                setProvince(data.provinces[0]);
                            }
                        }
                    })
                    .catch(err => {
                        console.error('获取省份列表失败:', err);
                        setError('获取省份列表失败');
                    });
            }, []);
            
            // 场景识别函数
            const recognizeScenarios = async () => {
                setLoading(true);
                setError(null);
                try {
                    const response = await fetch(`${API_BASE_URL}/recognize-scenarios`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            province,
                            date,
                            force_refresh: false
                        }),
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        setScenarioResults(data.data);
                        console.log('场景识别结果:', data.data);
                        
                        // 绘制净负荷曲线图
                        setTimeout(() => {
                            renderNetLoadChart(data.data.regulation_targets);
                        }, 100);
                    } else {
                        setError(data.error || '场景识别请求失败');
                    }
                } catch (err) {
                    console.error('场景识别请求错误:', err);
                    setError('场景识别请求发生错误');
                } finally {
                    setLoading(false);
                }
            };
            
            // 绘制净负荷曲线图
            const renderNetLoadChart = (regulationData) => {
                // 确保有数据且ECharts可用
                if (!regulationData || regulationData.length === 0 || !window.echarts) {
                    console.error('缺少数据或ECharts未加载');
                    return;
                }
                
                // 准备图表数据
                const hours = [];
                const loadValues = [];
                const netLoadValues = [];
                
                // 使用所有的时间点（一天有24小时，每小时可能有多个点）
                // 确保使用一整天的数据
                let dayData = regulationData;
                if (dayData.length > 96) { // 如果数据超过96点（15分钟间隔，24小时共96点）
                    dayData = dayData.slice(0, 96); // 只取前96个点
                }
                
                console.log(`图表数据点数: ${dayData.length}`);
                
                // 提取数据
                dayData.forEach(item => {
                    // 提取时间并格式化为小时:分钟
                    const dateObj = new Date(item.datetime);
                    const timeString = `${dateObj.getHours().toString().padStart(2, '0')}:${dateObj.getMinutes().toString().padStart(2, '0')}`;
                    hours.push(timeString);
                    
                    // 解析负荷值，确保是数字
                    loadValues.push(parseFloat(item.load) || 0);
                    netLoadValues.push(parseFloat(item.net_load) || 0);
                });
                
                // 初始化图表
                const chartDom = document.getElementById('netLoadChart');
                if (!chartDom) {
                    console.error('找不到净负荷图表DOM元素');
                    return;
                }
                
                const myChart = echarts.init(chartDom, isDarkMode ? 'dark' : null);
                
                // 图表配置
                const option = {
                    title: {
                        text: '负荷与净负荷24小时变化',
                        textStyle: {
                            fontSize: 16
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            let result = params[0].name + '<br/>';
                            params.forEach(param => {
                                result += param.seriesName + ': ' + param.value.toFixed(1) + ' MW<br/>';
                            });
                            return result;
                        }
                    },
                    legend: {
                        data: ['总负荷', '净负荷'],
                        right: '5%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true
                    },
                    dataZoom: [
                        {
                            type: 'inside',
                            start: 0,
                            end: 100
                        },
                        {
                            type: 'slider',
                            start: 0,
                            end: 100
                        }
                    ],
                    xAxis: {
                        type: 'category',
                        data: hours,
                        name: '时间',
                        nameLocation: 'middle',
                        nameGap: 30,
                        axisLabel: {
                            rotate: 45,
                            interval: function(index, value) {
                                // 每小时只显示一个刻度
                                return value.endsWith(':00');
                            }
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '负荷 (MW)',
                        nameLocation: 'middle',
                        nameGap: 50
                    },
                    series: [
                        {
                            name: '总负荷',
                            type: 'line',
                            data: loadValues,
                            smooth: true,
                            lineStyle: {
                                width: 3
                            },
                            symbolSize: 6,
                            itemStyle: {
                                color: '#5470c6'
                            },
                            markPoint: {
                                data: [
                                    { type: 'max', name: '最大值' },
                                    { type: 'min', name: '最小值' }
                                ]
                            }
                        },
                        {
                            name: '净负荷',
                            type: 'line',
                            data: netLoadValues,
                            smooth: true,
                            lineStyle: {
                                width: 3
                            },
                            symbolSize: 6,
                            itemStyle: {
                                color: '#91cc75'
                            }
                        }
                    ]
                };
                
                // 应用配置
                myChart.setOption(option);
                
                // 响应窗口调整大小
                window.addEventListener('resize', () => {
                    myChart.resize();
                });
            };
            
            // 为图表获取时间并格式化
            const formatDateTime = (dateTimeStr) => {
                const date = new Date(dateTimeStr);
                return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
            };
            
            // 字段格式化显示
            const formatField = (value, field) => {
                if (field.includes('reserve') || field === 'demand_response' || field === 'energy_storage' || field === 'load' || field === 'pv' || field === 'wind' || field === 'net_load') {
                    return value ? value.toFixed(1) + ' MW' : '-';
                }
                return value || '-';
            };
            
            return (
                <div className="space-y-6 fade-in animate-fade-in">
                    <div className="bg-white dark:bg-gray-800 shadow rounded-lg p-6">
                        <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">场景识别与调节需求</h2>
                        
                        {/* 控制面板 */}
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                            {/* 省份选择 */}
                            <div>
                                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                                    省份
                                </label>
                                <select 
                                    value={province}
                                    onChange={(e) => setProvince(e.target.value)}
                                    className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-primary-500 focus:border-primary-500 sm:text-sm rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                                >
                                    {provinces.map((p) => (
                                        <option key={p} value={p}>{p}</option>
                                    ))}
                                </select>
                            </div>
                            
                            {/* 日期选择 */}
                            <div>
                                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                                    预测日期
                                </label>
                                <input 
                                    type="date"
                                    value={date}
                                    onChange={(e) => setDate(e.target.value)}
                                    className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-primary-500 focus:border-primary-500 sm:text-sm rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                                />
                            </div>
                            
                            {/* 识别按钮 */}
                            <div className="flex items-end">
                                <button 
                                    onClick={recognizeScenarios}
                                    disabled={loading}
                                    className="w-full inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 dark:bg-primary-700 dark:hover:bg-primary-800 btn-hover"
                                >
                                    {loading ? '识别中...' : '识别场景'}
                                </button>
                            </div>
                        </div>
                        
                        {/* 错误信息 */}
                        {error && (
                            <div className="mb-4 p-4 border border-red-300 rounded-md bg-red-50 text-red-700 dark:bg-red-900/30 dark:text-red-400 dark:border-red-800">
                                {error}
                            </div>
                        )}
                        
                        {/* 只有当结果可用时才显示图表和表格 */}
                        {scenarioResults && scenarioResults.regulation_targets && (
                            <>
                                {/* 净负荷曲线图 */}
                                <div className="mb-8">
                                    <div className="mb-4 mt-8">
                                        <h3 className="text-lg font-semibold text-gray-900 dark:text-white">负荷与净负荷曲线</h3>
                                        <p className="text-sm text-gray-600 dark:text-gray-400">24小时负荷和净负荷变化趋势</p>
                                    </div>
                                    <div id="netLoadChart" style={{ width: '100%', height: '400px' }}></div>
                                </div>
                                
                                {/* 场景识别结果表格 */}
                                <div className="overflow-x-auto">
                                    <div className="mb-4 mt-8">
                                        <h3 className="text-lg font-semibold text-gray-900 dark:text-white">系统调节需求表</h3>
                                        <p className="text-sm text-gray-600 dark:text-gray-400">基于场景识别结果生成的系统调节需求</p>
                                    </div>
                                    
                                    <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                                        <thead className="bg-gray-50 dark:bg-gray-800">
                                            <tr>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                                                    时间
                                                </th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                                                    场景类型
                                                </th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                                                    调节需求
                                                </th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                                                    负荷 (MW)
                                                </th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                                                    净负荷 (MW)
                                                </th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                                                    向上备用 (MW)
                                                </th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                                                    向下备用 (MW)
                                                </th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                                                    需求响应 (MW)
                                                </th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                                                    储能需求 (MW)
                                                </th>
                                            </tr>
                                        </thead>
                                        <tbody className="bg-white divide-y divide-gray-200 dark:bg-gray-800 dark:divide-gray-700">
                                            {scenarioResults.regulation_targets.map((item, index) => (
                                                <tr key={index} className={index % 2 === 0 ? 'bg-white dark:bg-gray-900' : 'bg-gray-50 dark:bg-gray-800'}>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                                                        {formatDateTime(item.datetime)}
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap">
                                                        <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full 
                                                            ${item.scenario_type === '高峰负荷压力' ? 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-400' : 
                                                              item.scenario_type === '净负荷爬坡' ? 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-400' : 
                                                              item.scenario_type === '光伏波段风险' ? 'bg-orange-100 text-orange-800 dark:bg-orange-900/30 dark:text-orange-400' : 
                                                              item.scenario_type === '高可再生比例' ? 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-400' : 
                                                              item.scenario_type === '低谷负荷' ? 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-400' : 
                                                              'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'}`}>
                                                            {item.scenario_type}
                                                        </span>
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400">
                                                        {item.regulation_need}
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                                                        {formatField(item.load, 'load')}
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                                                        {formatField(item.net_load, 'net_load')}
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                                                        {formatField(item.upward_reserve, 'upward_reserve')}
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                                                        {formatField(item.downward_reserve, 'downward_reserve')}
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                                                        {formatField(item.demand_response, 'demand_response')}
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                                                        {formatField(item.energy_storage, 'energy_storage')}
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            </>
                        )}
                    </div>
                </div>
            );
        }

        // App组件加载完成后的钩子
        React.useEffect(() => {
            // 检查ECharts库是否正确加载
            console.log("页面加载完成，检查图表库状态...");
            const echartsStatus = typeof echarts !== 'undefined' ? '已加载' : '未加载';
            const chartJsStatus = typeof Chart !== 'undefined' ? '已加载' : '未加载';
            console.log(`ECharts状态: ${echartsStatus}`);
            console.log(`Chart.js状态: ${chartJsStatus}`);

            // 如果ECharts未加载，尝试重新加载
            if (typeof echarts === 'undefined') {
                console.warn("ECharts未加载，尝试重新加载...");
                const script = document.createElement('script');
                script.src = "https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js";
                script.onload = function() {
                    console.log("ECharts库已动态加载成功!");
                    window.echartsLoaded = true;
                    
                    // 如果已经有预测数据，重新渲染图表
                    if (predictionData) {
                        setTimeout(() => {
                            console.log("尝试使用新加载的ECharts重新渲染图表");
                            renderPredictionChart(predictionData);
                        }, 500);
                    }
                };
                script.onerror = function() {
                    console.error("ECharts库加载失败!");
                };
                document.head.appendChild(script);
            }
            
            // 获取省份列表
            fetchProvinces();
        }, []);

        // 获取省份列表的函数
        const fetchProvinces = async () => {
            try {
                const response = await fetch(`${API_BASE_URL}/provinces`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.provinces) {
                        setAvailableProvinces(data.provinces);
                        // 如果有可用省份且当前选择的省份不在列表中，更新选择
                        if (data.provinces.length > 0 && !data.provinces.includes(selectedProvince)) {
                            setSelectedProvince(data.provinces[0]);
                        }
                    }
                }
            } catch (error) {
                console.error('获取省份列表失败:', error);
                setError('获取省份列表失败');
            }
        };

        function ScenariosResultsView({ scenarios }) {
            return (
                <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm">
                    <div className="space-y-6">
                        {/* 总共识别的场景数量 */}
                        <div className="p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                            <h3 className="text-md font-semibold text-blue-700 dark:text-blue-300 mb-2">识别场景数量</h3>
                            <p className="text-2xl font-bold text-blue-800 dark:text-blue-200">{scenarios.length} <span className="text-sm font-normal">个能源场景</span></p>
                        </div>
                        
                        {/* 场景列表 */}
                        {scenarios.length > 0 && (
                            <>
                                <h3 className="text-lg font-semibold border-b pb-2 border-gray-200 dark:border-gray-700">场景详情</h3>
                                <div className="overflow-x-auto">
                                    <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                                        <thead className="bg-gray-50 dark:bg-gray-800">
                                            <tr>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">场景ID</th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">标签</th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">风电占比</th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">光伏占比</th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">上调备用</th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">下调备用</th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">需求响应</th>
                                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">储能</th>
                                            </tr>
                                        </thead>
                                        <tbody className="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">
                                            {scenarios.map((item, index) => (
                                                <tr key={index} className={index % 2 === 0 ? 'bg-white dark:bg-gray-900' : 'bg-gray-50 dark:bg-gray-800'}>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900 dark:text-gray-100">
                                                        {item.scenario_id || index + 1}
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                                                        {formatField(item.label, 'label')}
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                                                        {formatField(item.wind_penetration, 'wind_penetration', '%')}
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                                                        {formatField(item.solar_penetration, 'solar_penetration', '%')}
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                                                        {formatField(item.upward_reserve, 'upward_reserve')}
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                                                        {formatField(item.downward_reserve, 'downward_reserve')}
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                                                        {formatField(item.demand_response, 'demand_response')}
                                                    </td>
                                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                                                        {formatField(item.energy_storage, 'energy_storage')}
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            </>
                        )}
                    </div>
                </div>
            );
        }
    </script>
</body>
</html> 